[{"title":"数字电子技术学习及思考记录","url":"/archives/39715/","content":"\n```mermaid\n---\nconfig:\n  theme: neutral\n  layout: tidy-tree\n---\nmindmap\nroot((数字电子技术))\n  basic1(数码与码制)\n  basic2{{逻辑代数基础}}\n  basic3))门电路((\n  basic4{{组合逻辑电路}}\n  basic5[半导体存储电路]\n  basic6(时序逻辑电路)\n  basic7)脉冲波形的产生和整形电路(\n```\n\n---\n\n# 一、数制和码制\n\n```mermaid\n---\nconfig:\n  theme: neutral\n  layout: tidy-tree\n---\nmindmap\nroot((数制和码制))\n  1{{数制}}\n    1)常用数制(\n      1(数制间的相互转换)\n  2{{码制}}\n    1)常用编码(\n      1(BCD)\n        1)8421BCD(\n        2)5421BCD(\n        3)2421BCD(\n        4)余3码(\n      2(ASCII)\n      3(格雷码)\n\n```\n常用的几种进制：\n\n- 二进制(Binary)\n- 八进制(Octal)\n- 十进制(Decimal)\n- 十六进制(Hexadecmial)\n\n| 二进制 |八进制 | 十进制|十六进制|\n|:-----:|:-----:|:-----:|:-----:|\n|  0000 |   0   |   0   |    0  |\n|  0001 |   1   |   1   |    1  |\n|  0010 |   2   |   2   |    2  |\n|  0011 |   3   |   3   |    3  |\n|  0100 |   4   |   4   |    4  |\n|  0101 |   5   |   5   |    5  |\n|  0110 |   6   |   6   |    6  |\n|  0111 |   7   |   7   |    7  |\n|  1000 |  10   |   8   |    8  |\n|  1001 |  11   |   9   |    9  |\n|  1010 |  12   |  10   |    A  |\n|  1011 |  13   |  11   |    B  |\n|  1100 |  14   |  12   |    C  |\n|  1101 |  15   |  13   |    D  |\n|  1110 |  16   |  14   |    E  |\n|  1111 |  17   |  15   |    F  |\n|  ..   |  ..   |  ..   |   ..  |\n\n---\n\n## 进制转换\n各种不同的数制之间可以相互转换\n\n### 1.二进制/八进制/十六进制相互转换\n- 八进制的每一位可以由三位二进制数字来表示\n- 十六进制的每一位可以由四位二进制数字表示\n\n可以将二进制三个或两个对应为一组，对应八进制或十六进制中的一位数字\n\n### 2.其他进制转十进制\n以下面这个二进制数为例\n$$101.11$$\n\n|  $1$  |  $0$  |  $1$  |  $.$  |  $1$    |  $1$    |\n|:-----:|:-----:|:-----:|:-----:|:-------:|:-------:|\n|  $4$  |  $2$  |  $1$  | $dot$ | $0.5$   | $0.25$  |\n|  $2^2$|  $2^1$|  $2^0$| $dot$ | $2^{-1}$| $2^{-2}$|\n|  $N^2$|  $N^1$|  $1$  | $dot$ | $N^{-1}$| $N^{-2}$|\n\n十进制数=\n$$1*2^2+0*2^1+1*1+1*2^{-1}+1*2^{-2} = 5.75$$\n\n### 3.十进制数转其他进制\n$10.375$转换成二进制:\n\n小数点之前：连续除以2取余数直到整数部分为零\n\n- 第一次：0  最低位\n- 第二次：1    ^\n- 第三次：0    | \n- 第四次：1    |\n- 第五次：0  最高位\n\n小数点之后：连乘2取整直到小数部分为零\n\n- 第一次：0 (0.75)\n- 第二次：1 (1.45)\n- 第三次：0 (0.90)\n- 第四次：1 (1.80) <<<|\n- 第五次：1 (1.60) \n- 第六次：1 (1.20) \n- 第七次：0 (0.40) \n- 第八次：0 (0.80) <<<|                     \n\n无法使小数部分归零,需限制精度取值\n\n小数部分先算出来的是高位，从上往下写\n$$01010.0101110……$$\n这里算的保留了最高位的零，因为我在C语言中把一个十进制整数转换成二进制字符串的时候发现这样算最高位始终会是一个零，这里提醒我注意倒序字符串之前要把最高位换成字符串结束符`\\0`\n\n## 几种常见编码\n- BCD(Binary Coded Decmial)码\n  - 8421 BCD码\n  - 5421 BCD码\n  - 2421 BCD码\n  - 余3码\n- 格雷码\n- ASCII\n- 汉明码\n- 奇偶数校验码\n\n---\n\n## ⭕机器数\n一个数在计算机中以二进制的形式表示，做高位是符号位，0为正，1为负，\n带符号位的机器数对应的真正数值是机器数的真值\n\n### 1.原码（Sign-Magnitude Representation)\n在原数值前加一位符号位构成及机器数\n\n对于一个五位原码（有一位用来存储符号），其能表示的范围为$[-15,15]$即$[-2^4,2^4]$，共有$2^5-1 = 31$个数\n\n$\\left. \\begin{array}{lcl} 00000 \\\\ 10000 \\end{array} \\right \\} \\text{两个均代表零}$\n\n### 2.反码（One's complement）\n- 正数的反码是其本身（这也没变化啊，还得再取一个名字？）\n- 负数的反码符号位不变，其余各位取反\n\n因为负数的反码与原码数值位为取反关系，\n所以原码和反码的数值部分相加能得到当前位数能表示的最大数。\n这个与下面通过补码实现的加减法计算就息息相关了，\n我找的几个资料都是直接说是为了实现计算而引入的。\n但是看了那些还是对反码的意义不太清楚，最后找到了一篇说是过渡阶段，\n早期计算机使用反码来表示负数，但是还是没有讲清楚。\n很多网站上都是说是为了计算机计算，其实都是一个个照着定义搬下来的，\n根本不知道为什么要有补码和反码。\n\n### 3.补码（Two's complement)\n- 正数的补码是其本身\n- 负数的补码是其反码加1\n\n刚开始这么就这样引入三个概念，但是这概念应该是实际应用之后才产生的。\n现在却是先讲了概念，然后介绍其应用，搞得一头雾水，还要去记这三种东西。\n\n找了一上午终于看到了一个解释，醍醐灌顶\n\n补码其实很简单，一个两位数十进制数的加法：\n$$27 + 99 = 126$$\n对于一个只有两位的十进制数，这里最高位1就没了，得到的结果就是26。刚好就是\n$$27-1 = 26$$\n$$99 + 1 = 100$$\n用加法实现了减法运算，假如要算$50 - 45$，可以转化成$50 + 55$，然后将其超过两位的部分去掉，\n就会得到和$50 - 45$一样的答案，\n\n这上面都是用大数减小数（绝对值），变成了大数加其补数，但是当小数减大数时这样算就会出现一个问题$45 - 50 = -5$，按上面编程加它补数的话就会变成$95$\n\n一块表有$0 - 12$共十三个数，\n\n\n二进制的计算规则和十进制并没什么区别\n\n---\n\n# 二、逻辑代数\n均采用正逻辑\n\n```mermaid\n---\nconfig:\n  theme: neutral\n  layout: tidy-tree\n---\nmindmap\nroot((逻辑代数))\n  A{{基础逻辑运算及其真值表}}\n    1)基本运算(\n      1(与 **AND** )\n      2(或 **OR** )\n      3(非 **NOT** )\n    2)由基本运算复合的常用运算(\n      1(与非 **NAND** )\n      2(或非 **NOR** )\n      3(同或 **XOR** )\n      4(异或 **XNOR** )\n\n```\n\n## 1.基础逻辑运算及其真值表\n- 与(AND)\n- 非(NOT)\n- 与非(NAND)\n- 或(OR)\n- 或非(NOR)\n- 异或(XOR)\n- 同或(XNOR)\n\n### 1.非(NOT)\n对输入取反\n$$L = \\overline{A}$$\n\n| 输入(A)  | 输出(L) |\n|:--------:|:------:|\n|     0    |    1   |\n|     1    |    0   |\n\n### 2.与(AND)\n只有输入均为1时输出1\n$$L = A \\cdot B = AB$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    1   |\n\n### 3.与非(NAND)\n对与取反\n$$L = \\overline{A \\cdot B }= \\overline{AB}$$\n\n - [ ] 上次玩图灵完备这个游戏说是能由与非门组成其他所有逻辑门，等学完逻辑门就单独写一篇\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    0   |\n\n### 4.或(OR)\n输入中有1时输出1\n$$L = A + B$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    1   |\n\n### 5.或非(NOR)\n对或取反\n$$L = \\overline{A + B}$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    0   |\n\n### 6.异或(XOR)\n只输入一个1时输出1，比`OR`少一个全为1\n$$L = A \\overline{B} + \\overline{A} B = A \\oplus B$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    0   |\n\n### 7.同或(XNOR)\n输入全相同时输出1，比`AND`多一个输入全为0\n$$L = AB + \\overline{A} \\overline{B} = A \\odot B = \\overline{A \\oplus B}$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    1   |\n\n### 小结\n- $NAND = \\overline{AND}$\n- $NOR = \\overline{OR}$\n- $XNOR = \\overline{NOR}$\n\n构造一个XOR：\n\n```mermaid\n---\nconfig: \n    theme: base\n    layout: dagre\n\n---\nflowchart LR\n    in1[\"输入1\"]\n    in2[\"输入2\"]\n    OR[\"OR\"]\n    AND[\"AND\"]\n    NAND[\"NAND\"]\n    out[\"输出\"]\n\n        in1-->OR\n        in2-->OR\n        in1-->NAND\n        in2-->NAND\n        OR-->AND\n        NAND-->AND\n        AND-->out\n\n```","categories":["note"]},{"title":"Optimization","url":"/archives/21457/","content":"\n# 最优化理论学习笔记\n目的：\n找到解决问题的最佳方法\n\n问题分类：\n\n- 函数极值$f(x)$：静态优化\n- 泛函极值$f(u+v)$：动态优化\n\n---\n\n## 一、正定矩阵(Positive Matrix)\n方阵$A$对任意一个非零向量$\\mathbf{x}$，总是$x^TAx>0$。$A$特征值全为正数。\n\n### 判断一个矩阵是否为正定矩阵\n- 判断特征值是否全为正数  $\\det(\\lambda\\mathbf{I}-\\mathbf{A})=0$\n- 顺序主子式全大于零\n\n## 二、海塞矩阵(Hessian Matrix)\n$$\\nabla^2f(\\mathbf{x})=\\begin{bmatrix}\n    \\dfrac{\\partial^2 f}{\\partial x_1^2} & \\dfrac{\\partial^2 f}{\\partial x_1 \\partial x_2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\n    \\dfrac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\dfrac{\\partial^2 f}{\\partial x_2^2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    \\dfrac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\dfrac{\\partial^2 f}{\\partial x_n \\partial x_2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_n^2} \\\\\n\\end{bmatrix}$$\n\n## 三、求多元函数极值\n### 1.求出驻点\n对多元函数$f$求一阶偏导，让它等于0求出驻点\n\n$$\\dfrac{\\partial f}{\\partial x}=\\begin{pmatrix}\n   \\dfrac{\\partial f}{\\partial x_1}\\\\\n   \\dfrac{\\partial f}{\\partial x_2}\\\\\n   \\vdots\\\\\n   \\dfrac{\\partial f}{\\partial x_n}\\\\\n\\end{pmatrix}=0$$\n\n### 2.判断是不是极值点\n驻点可能会有多个，假设下面是其中一个驻点\n\n$$x=\\begin{pmatrix}\n   x_1^*\\\\ \n   x_2^*\\\\ \n   \\vdots\\\\\n   x_n^*\\\\ \n\\end{pmatrix}$$\n\n将其带入到海塞矩阵中，判断海塞矩阵的正负定性。\n\n- 海塞矩阵正定，该点是极小值点\n- $f(x)$ 的极大值是 $-f(x)$ 的极小值\n\n求极值：\n$$f(x)=x^4+8x^3+22x^2+24x$$\n\n\n---\n## 四、凸集和凸函数\n### 1.凸集\n**定义** ：$D\\subset \\mathbb{R}^n，\\forall x, \\quad y \\in D，\\forall \\lambda \\in[0,1]满足\\lambda x(1-\\lambda)y\\in D$，称D为凸集合\n\n**特点** ：即内部无洞，边缘无内凹，任意两点间的连线仍然在集合内部\n\n**性质** : \n\n- 若$D$，$A$都为凸集，则$\\mathbf{D} \\bigcap \\mathbf{A}$，仍为凸集\n- \n\n**常见的凸集** \n$\\alpha \\in \\mathbb{R}^n$\n\n- **超平面** ：$H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x=b \\right \\}$\n- **半空间（闭）** ：$H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x\\le b \\right \\}，H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x\\ge b \\right \\}$\n- **半空间（开）** ：半空间（闭）去掉$\\alpha^T x=b$\n\n对与上面这三种的证明方法一致，这里以超平面为例：\n$$\\alpha \\left [\\lambda x + (1-\\lambda)y \\right ] = b(\\lambda + 1 - \\lambda) = b$$上面简单证明了超平面为凸集\n\n证明$\\mathcal{L}=\\left \\{ x\\in\\mathcal{R}^n|x=x_0+\\lambda d \\right\\}$，为凸集，$d,x_0$是给定非零向量, $\\lambda$为任意实数，其证明方法也是与上面一致的，只需要将数据带入就行。\n\n### 2.凸函数\n对于一个非空凸集$S$\n\n函数$f:D \\to R$\n\n$\\forall x, y \\in D$，$\\forall \\alpha \\in[ 0,1 ]$\n\n$f[ \\alpha x + (1-\\alpha)y ] \\le  \\alpha f(x) + (1-\\alpha)f(y)$\n\n则$f$为凸函数，其实就是一种图像上直观的关系，不过观察并不能判断整个实数域上的情况\n\n$f$上取两点可以做一条弦，在这两点之间函数的图像部分不在这条弦上方，对于所有的弦都成立就是凸函数\n\n二次函数$f(x)=x^2$很明显就是一个凸函数\n\n\n\n当不存在相等情况时为严格凸函数\n\n线性函数一定是凸函数\n$$f(x)=c_1 x_1 + c_2 x_2 + c_3 x_3 + \\ldots + c_n x_n$$\n可以写成$f(x) = c^Tx$\n\n证明：\n$$\\begin{aligned}\n   f[\\alpha x + (1-\\alpha) y] & = c^T[\\alpha x + (1-\\alpha)y] \\\\\n                              & = c^T \\alpha x + c^T (1-\\alpha)y \\\\\n                              & = \\alpha c^T x + (1-\\alpha) c^T y \\\\\n                              & = \\alpha f(x) + (1-\\alpha)f(y)\n\\end{aligned}$$\n\n$f(x) = \\max \\{x_1, x_2, \\ldots ,x_n \\}$也是凸函数\n\n#### 根据海塞矩阵判断凸函数\n- 半正定：$\\nabla^2f(x) \\ge  0 \\Rightarrow 凸函数$\n- 正定：$\\nabla^2f(x) > 0 \\Rightarrow 严格凸函数$\n\n#### 凸函数性质\n局部最小即全局最小\n\n## 线性规划(Linear Programming)\n如:求$\\min z = c_1 x_1 + c_2 x_2 + \\ldots +c_n x_n = c^T x$\n\n- 决策变量($x_1, x_2, \\ldots, x_n$)\n- 目标函数($\\min z, \\max z$)\n- 约束条件\n\n如：求$\\min z = 4x_1 + 2x_2 + 3x_3 + 6x_4$\n$$s.t = \\begin{cases}\n   & x_1 - 2x_2 + 3x_3 - 2x_4 \\le  -6 \\\\\n   & 2x_1 + 7x_2 - 6x_3 + x_4 \\ge  7 \\\\\n   & 3x_1 - x_2 + 2x_3 - 5x_4 = -8 \\\\\n   & x_1 \\ge  0,\\quad x_2 \\le  0,\\quad x_3<=0,\\quad x_4\\in \\mathbb{R} \n\\end{cases}$$\n\n- **决策变量** ：$x_1,\\quad x_2,\\quad x_3,\\quad x_4$\n- **目标函数** ：$\\min z = 4x_1 + 2x_2 + 3x_3 + 6x_4$\n\n### 标准型(Stand Form)\n所有变量均不小于零，约束条件均为 **等式** 且**右侧常量为非负数**\n\n上面这个例子可以通过替换变量和加入变量化为标准型\n$$\\min z = 4x_1 + 2x_2 + 3x_3 + 6x_4$$\n$$s.t = \\begin{cases}\n   & x_1 - 2x_2 + 3x_3 - 2x_4 \\le  -6 \\\\\n   & 2x_1 + 7x_2 - 6x_3 + x_4 \\ge  7 \\\\\n   & 3x_1 - x_2 + 2x_3 - 5x_4 = -8 \\\\\n   & x_1 \\ge  0,\\quad x_2 \\le  0,\\quad x_3 \\le 0,\\quad x_4\\in \\mathbb{R} \n\\end{cases}$$\n\n- $x_2' = -x_2$替换$x_2$\n- $x_3' = -x_3$替换$x_3$\n- $x_4' - x_4''$替换$x_4$，让$\\quad x_4',\\quad x_4'' \\ge 0$\n\n$$\\min z = 4x_1 - 2x_2' - 3x_3' + 6(x_4' - x_4'')$$\n$$s.t = \\begin{cases}\n   & -x_1 - 2x_2' + 3x_3' + 2(x_4' - x_4'') \\ge 6 \\\\\n   & 2x_1 - 7x_2' + 6x_3' + x_4' - x_4'' \\ge 7 \\\\\n   & -3x_1 - x_2' + 2x_3' + 5(x_4' - x_4'') = 8 \\\\\n   & x_1,\\quad x_2',\\quad x_3', \\quad x_4', \\quad x_4'' \\ge 0\n\\end{cases}$$\n\n接下来要把约束条件变为等式，要引入盈余变量(Surplus Variables)使约束条件化为等式\n\n- 引入的盈余变量也要为非负数\n\n因此可以减去一个引入的非负盈余变量使右端化为零\n\n引入盈余变量$s_1,\\quad s_2$\n\n$$\\min z = 4x_1 - 2x_2' - 3x_3' + 6(x_4' - x_4'')$$\n$$s.t = \\begin{cases}\n   & -x_1 - 2x_2' + 3x_3' + 2(x_4' - x_4'') - s_1 = 6 \\\\\n   & 2x_1 - 7x_2' + 6x_3' + x_4' - x_4'' - s_2 = 7 \\\\\n   & -3x_1 - x_2' + 2x_3' + 5(x_4' - x_4'') = 8 \\\\\n   & x_1,\\quad x_2',\\quad x_3', \\quad x_4', \\quad x_4'', \\quad s_1,\\quad s_2 \\ge 0\n\\end{cases}$$\n到这就化成标准型了\n\n## 基本可行解(Basic Feasible Solution)\n对于一个标准型$\\max f(x) = c^T x$\n\n约束条件$A x= b$\n$$A x=\n\\begin{pmatrix}\n   a_{11} & a_{12} & \\cdots & a_{1n} \\\\\n   a_{21} & a_{22} & \\cdots & a_{2n} \\\\\n   \\vdots & \\vdots & \\ddots & \\vdots \\\\\n   a_{m1} & a_{m2} & \\cdots & a_{mn} \\\\\n\\end{pmatrix}\n\\begin{pmatrix}\n   x_1 \\\\\n   x_2 \\\\\n   \\vdots \\\\\n   x_n\n\\end{pmatrix}\n= \n\\begin{pmatrix}\n   b_1 \\\\\n   b_2 \\\\\n   \\vdots \\\\\n   b_n\n\\end{pmatrix}$$\n\n要从这个矩阵函数的解中找出使$f(x)$最大的那个解，线性规划这一点很奇妙，其解集为凸集，类似于两个变量线性规划问题\n\n两个变量约束可以很容易画出其解集，然后找一条跟目标函数平行的线在图像上平移，\n初中很多这种问题， **能使目标函数最大或最小的解总在多边形的顶点上**\n\n**线性规划问题对应的线性方程组的解集一定是凸集**，\n因为其解集为每一个约束条件的解集的交集，凸集的交集一定是凸集。\n\n解集是凸集的话，对于不是唯一解的情况下，它如果最优解一定是在凸多边形（凸多面体）的顶点，除了解集在某个方向无限延伸，目标函数无界的情况\n\n\n\n**矩阵函数**\n$$A_{m \\times n}x$$\n\n|    自然定义域      | 映射法则 |   值域     |     到达域      |\n|:-----------------:|:-------:|:----------:|:---------------:|\n|  $\\mathbb{R}^n$   |  $A$    | $colsp(A)$ |  $\\mathbb{R}^m$ |\n\n其值域是对$A$列向量的线性组合，对应空间中的一块区域，\n\n根据线性规划约束条件的系数矩阵，选出一组 **基向量** （即一个极大无关列向量组）\n对应的变量作为 **基变量** ，其余作为 **非基变量**\n\n将$A$分块分为两部分： **基向量组成的基矩阵** $B$ 和 **非基向量组成的非基矩阵**$N$\n\n$A = [B|N]$\n\n约束条件变为\n\n$B x_B + N x_N = b$\n\n**基本解** ：令非基变量$x_N$等于$0$，解出：$x_B = B^{-1}b$\n\n**基本可行解**：基本解中 $x_B \\ge 0$的解，在约束条件中对所有变量的约束是非负，只有这种才是有效的解\n\n为什么要找基本解呢？刚才分析过了他的最优解是在凸多面体的顶点上\n\n求$\\min z = x_1 + 2x_2 + 3x_3$\n假如说我有三个变量：$x_1,\\quad x_2,\\quad x_3$\n\n其中前两个是基变量对应的基向量分别为 \n$$p_1 = \n\\begin{pmatrix} \n   1\\\\\n   0\n\\end{pmatrix},\\quad \np_2 = \n\\begin{pmatrix}\n   0\\\\\n   1\\\\\n\\end{pmatrix},\\quad\np_3 = \n\\begin{pmatrix}\n   1\\\\\n   1\n\\end{pmatrix}$$\n\n$A x = [B|N] x = b$\n$$\\begin{pmatrix}\n   1 & 0 & 1\\\\\n   0 & 1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n   x_1\\\\\n   x_2\\\\\n   x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n   2\\\\\n   1\n\\end{pmatrix}$$\n\n矩阵的秩为2\n\n$p_1,\\quad p_2$确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到$b$就是对应的那个解\n$\\begin{pmatrix}\n   2\\\\\n   1\\\\\n   0\n\\end{pmatrix}$\n\n$p_1,\\quad p_3$确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到$b$就是对应的那个解\n$\\begin{pmatrix}\n   1\\\\\n   0\\\\\n   1\n\\end{pmatrix}$\n\n$p_2,\\quad p_3$确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到$b$就是对应的那个解\n$\\begin{pmatrix}\n   0\\\\\n   -1\\\\\n   2\n\\end{pmatrix}$\n\n这三个点确定了一条直线（仅有一个自由变量）\n\n每一个变量的取值都是在不同方向上贡献变化，把三个变量当作三个方向：即三个不同的轴向，其中两个方向可以构成一个平面，线性规划的求解，**要求全为正数**\n\n让其中非基变量等零，可以找出与三个平面的交点，边界条件，一定是在顶点上的，如果解集是直线则是线段的端点\n\n添加盈余变量后，应该是贡献的轴向变多，对应的基本可行解集合是升维后的解集其他非基变量没有贡献时候的交点，是一个顶点（其他任何一个变量发生变化都会往不同的方向贡献），因此这个点一定是顶点\n\n","categories":["note"]},{"title":"GCC基本使用","url":"/archives/21724/","content":"\n# 一.单个文件编译\n\n```bash\ngcc -v -Wall xxx.c -o xxx\n```\n\n- `-Wall` 在编译时对一些常见错误，潜在问题给出警告，方便发现问题，修正代码\n- `-o` **output** 指定编译生成的文件名\n    - 可以顺便指定目录\n- `-v` 列出一些详细信息，当编译出错时会非常有用\n    - 搜寻**头文件（header files）** 和 **库文件（libraries）**的目录\n    - 用于链接的**目标文件（object files）**和**库文件（libraries）**\n\n# 二.多个文件编译\n\n## 1.独立编译\n\n每个文件编译后生成一个 **目标文件（object file）** ，而不产生可运行文件，产生对应的`.O`或者`.obj`文件,\n\n**独立编译**\n\n```bash\ngcc -Wall -c xxx.c\n```\n`-c`产生相应的目标文件，这一步同样可以用`-o`参数指定文件名，否则与源文件同名\n\n## 2.链接\n\n所有的目标文件通过连接器(linker)链接在一起，产生一个独立的可运行文件。\n\n**链接**\n```bash\ngcc xxx.o yyyy.o -o Name\n```\n对于较大的工程，将所有源码写在一个源文件中每次修改重新编译很费时。\n这时候需要将源文件模块化编程，每次只需要重新编译修改过的部分.\n### 2.1链接顺序\n\ngcc无需指定链接顺序，对较老的编译器，有可能需要指定顺序，调用函数者放在前，定义函数者放在后。\n\n## 3.重编译重链接\n\n对发生改变的源文件重新编译，再重新链接\n\n# 三.链接外部库\n\n## 1.链接外部库的方式\n```bash\ngcc -Wall main.c /usr/lib/libm.a -o xxx\n```\n绝对路径链接目标库`libm.a`\n\n```bash\ngcc -Wall main.c -lNAME -o xxx\ngcc -Wall main.c /usr/lib/libm.a -o xxx //与下面作用相同\ngcc -Wall main.c -lm io xxx\n```\n对于库文件`libNAME.a`,可以用`-lNAME`链接 \n\n```bash\ngcc -Wall main.c -L$LibPath -lNAME\n```\n\n## 搜索路径\n\n`-I`和`-L`参数指定搜索路经\n\n- `-I`指定头文件搜索目录\n- `-L`指定库文件搜索目录\n\n# 使用`ar`创建一个库\n\n```bash\nar cr libNAME.a file1.o file2.o ... filen.o\n```\n`cr`\n\n- `c` create 创建\n- `r` replace 替换\n\n```bash\nar t libNAME.a\n```\n列出`libNAME.a`里的目标文件\n\n## 创建一个库`libTEST.a`并使用\n### 1.创建头文件和源码\n\n`libTEST.h`,`func1.c`,`func2.c`,`main.c`\n\n\n```c:func1.c\n//func1.c\n#include \"libTEST.h\"\nint func1(int x, int y){\n    return (x+y);\n}\n```\n```c:func2.c\n//func2.c\n#include <stdio.h>\nvoid func2(int x){\n    printf(\"Result = %d\", x);\n}\n```\n```c:libTEST.h\n//libTEST.h\n#ifndef __LIBTEST_H__\n#define __LIBTEST_H__ \n\nint func1(int x, int y);\nvoid func2(int x);\n\n#endif \n```\n```c:main.c\n//main.c\n#include \"libTEST.h\"\nint main(){\n    int i;\n    i = func1(1, 2);\n    func2(i);\n}\n```\n### 2.创建目标文件\n\n```bash\ngcc -Wall -c func1.c func2.c\n```\n此时产生目标文件`func1.o`,`func2.o`\n\n### 3.将目标文件创建成库\n\n```bash\nar cr libTEST.a func1.o func2.o\n```\n生成了库文件`libTEST.a`\n\n### 4.使用库文件\n在编译时链接刚刚创建的库`libTEST.a`，要将`main.c`放在`libTEST.a`之前\n\n!⭕!库文件`.a`为二进制文件。`main.c`调用`libTEST.a`，放在前面。\n```bash\ngcc -Wall main.c libTEST.a\n```\nOR\n添加搜索库路径参数\n```bash\ngcc -Wall main.c -L. -lTEST\n```\n运行输出文件，程序结果为`3`","categories":["note"]},{"title":"十月周末总结","url":"/archives/19160/","content":"\n## 第一次周末总结 \n\n### 10月6 - 10月12\n\n6号是中秋节，10月1 — 10月8是国庆和中秋假期，整个国庆假期都在学校，每天打打CS2。国庆假期升级了电脑的内存，换了两根24G DDR5 5600MHz的内存条，原来的是两根8G实在是有点不够用。SW开个模型就要报内存可使用内存不够用。刚开始还计划假期几天出去玩玩，比如去龙潭山，朱雀山看看吉林的秋景。最后这八天都没有出去走一走。\n\n中秋节晚上和舍友邓一块去了河南街的福源馆，买了几个月饼，说实话这个月饼中规中矩，吃起来没有什么特别的，就是一种很熟悉的味道，但是挺贵的，最便宜的六块五一个。我买了两个六块五的，一个八块的，到宿舍给了舍友一个。从9号开始上课到12号，周六补了10月八号的课。\n\n### 学习方面\n\n#### 物理 \n\n假期补了前面的一点作业，是关于光的偏振的，自然光光强$I_0$透过偏振片后光强变为原来的一半$I_1=I_0/2$，产生的线偏振光与的振动方向与另一个偏振片的偏振化方向夹角$\\alpha$，则透射光的光强$I = I_1\\cos^2\\alpha$\n上面这个就是 **（马吕斯定律）** 证明：是将入射光的光矢量振幅$E_0$分成 **垂直** 和 **平行** 于偏振片偏振化方向的分量 $E_0\\sin\\alpha$ 和 $E_0\\cos\\alpha$ ，光强与振幅的二次方成正比，$\\begin{gather*}\\frac{I}{I_1}=\\frac{(E_0\\cos\\alpha)^2}{E_0^2}\\end{gather*}$ \n\n上课新学习了电场强度通量，和高斯定理。电场强度通量在书中是这么说的： **通过电场中任一给定面积的电场线根数，称为通过该面积的电场强度通量,用$\\Phi_e$表示**。感觉这是一种很好理解 **高斯定理** 的方式。 **高斯定理** 的表述： **穿过任意闭合曲面的电场强度通量，等于曲面内所包围的全部电荷的电荷量的代数和除以$\\varepsilon_0$**。\n\n$\\begin{gather*}\n\\Phi_e=\\oint_S E\\cdot \\,d\\mathrm{S}=\\frac{1}{\\varepsilon_0}\\sum_{i=1}^{n} q_i\n\\end{gather*}$\n\n然后又学了电势差，电势，上课算了一些常见的物理模型：（下次补充）\n\n#### 51单片机\n\n- [x] 点亮一颗LED，LED流水灯，独立按键控制LED状态，独立按键控制LED移位\n- [x] 数码管静态显示，动态显示\n\n在控制LED的编程过程中用到的较多的是\n- 2进制和16进制转换\n- 按位取反\n- 延时\n\n数码管操作起来比LED复杂许多，掌握74HC138译码器使用实现数码管的位选，74HC245控制段选，对于动态显示要消影。\n\n#### 电路原理\n\n\n#### 最优化理论\n目的：\n找到解决问题的最佳方法\n问题分类：\n- 函数极值$f(x)$：静态优化\n- 泛函极值$f(u+v)$：动态优化\n\n\n#### 体育课3200M\n跑了 13'28\"","categories":["life"]},{"title":"Latextest","url":"/archives/10000/","content":"# latex 希腊字母表\n|Latex     |小写符号   | Latex       |大写符号    |\n|:--------:|:--------:|:----------:|:----------:|\n|`\\alpha`  |$\\alpha$  |`\\mathrm{A}`|$\\mathrm{A}$|\n|`\\beta`   |$\\beta$   |`\\mathrm{B}`|$\\mathrm{B}$|\n|`\\gamma`  |$\\gamma$  |`\\Gamma`    |$\\Gamma$    |\n|`\\delta`  |$\\delta$  |`\\Delta`    |$\\Delta$    |\n|`\\zeta`   |$\\zeta$   |`\\Zeta`     |$\\Zeta$     |\n|`\\epsilon`|$\\epsilon$|`\\mathrm{E}`|$\\mathrm{E}$|\n|`\\eta`    |$\\eta$    |`Eta`       |$\\Eta$      |\n","categories":["note"]},{"title":"Hello World","url":"/archives/16107/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"C语言初识之猜数游戏","url":"/archives/26716/","content":"\n转入自动化专业之后以后的学习会用到C语言，本来自动化专业大一就学过 ***《C语言程序设计》*** ，所以我需要对这一门课程进行补修。刚好我也对这方面感兴趣，顺便提前学习了一点点，现在我自学的基本都是看菜鸟教程和一点点实践出来的。突发奇想写个猜数字的游戏，很简陋，只有命令行界面。这个文章简要记录了我这个程序的变化及想法的实现。\n\n我刚开始是只写了能运行一次的，也就是下面这个流程，但是玩完一次还得再去运行，不能直接再次开始游戏，想再玩的话很麻烦，还得再打开一次。然后就想办法让他能再次运行，我的想法是通过一个`while`循环来实现，先定义了循环变量`r`并初始化为2，然后输出 **游戏开始[1]** 和 **退出选项[2]** 引导玩家去输入选择开始或者退出游戏，当输入`1`就开始游戏，这里直接选择了小于等于1开始循环。然后初始化 **随机数发生器** ，从1-100选择一个数作为这次游戏的答案，定义并初始化用于记录尝试次数的变量`n = 1`，因为就算第一次输入正确也是尝试了1次，定义用于玩家输入的变量`x`，告知游戏规则，由玩家输入数字，输入不等于答案时告知大小关系，变量`n`加1，告知玩家再次尝试，这是为了玩家清楚现在的状态，不是死机。当输入等于答案时退出这层循环，然后输出尝试次数和正确答案，询问是否再玩一次，再次由玩家输入到变量`r`\n\n```mermaid\n---\nconfig:\n    theme: neutral\n    layout: dagre\n\n---\nflowchart TD\n    A[\"猜数游戏\"]\n    answer[\"随机生成答案\"]\n    input[\"输入\"]\n    false[\"记录尝试次数，告知与答案大小关系\"]\n    true[\"输出尝试次数，正确答案\"]\n    stop[\"结束游戏\"]\n    A -->|告知规则| answer\n    answer --> input\n    input --> |猜错| false\n    input --> |猜对| true\n    false --> input\n    true --> stop\n```\n\n修改后的流程图和代码是这样的，算是一个很简单的小游戏了\n\n```mermaid\n---\nconfig:\n  theme: neutral\n  layout: dagre\n\n---\nflowchart TD\n    A[\"猜数游戏\"] -->|输入1| C(\"随机生成答案\")\n    A -->|输入2| D(\"结束游戏\")\n    C --> E(\"猜数\")\n    E -->|猜对| F(\"尝试次数，正确答案\")\n    E -->|猜错| G(\"告知与答案大小关系\")\n    G -->|记录尝试次数| E\n    F --> A\n    R(告知规则) --> A\n```\n\n\n\n```c\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\nint main()\n{\n    int r = 2;\n    printf(\"\\tGuess NUMBER game\\t\\n\\n\\t    [1]Start\\t\\n\\n\\t    [2]EXIT\\t\\n\");\n    scanf(\"%d\", &r);\n    while( r <= 1 ) // 开始游戏\n    {\n        srand((unsigned int)time(NULL));\n        int answer = rand() % 101 + 1; // 从1-100随机选取一个数字\n        int x = 0;\n        int n = 1; // 用于记录尝试次数的变量\n        printf(\"\\tGuess a NUMBER from 1 to 100\\t\\n\\nI'll tell you whether IT is bigger or smaller\\nin comparison with the NUMBER i selected\\n\\n\");\n        printf (\"Enter Your ANSWER: \");\n        scanf(\"%d\", &x);\n        while(x != answer) // 猜错开始循环\n        {\n            if(x < answer) // 输入小于答案\n            {\n                printf(\"Your answer is Smaller\\n\");\n            }\n            else // 输入大于答案\n            {\n                printf(\"Your answer is Bigger\\n\");\n            }\n            printf(\"Try again: \");\n            n++;\n            scanf(\"%d\", &x);\n        }\n        printf(\"You've tried %d times, the Answer is %d\\n\", n, answer);\n        printf(\"[1] PLAY AGAIN\\n[2] EXIT.....\\n\");\n        scanf(\"%d\", &r);\n    }\n    return 0;\n}\n```\n\n在 ***《软件技术基础》*** 这门刚开始学的课程中老师讲的算法的**时间复杂度**，讲了**大O表示法（Big O Notation）**，举了一些例子\n\n- **O(1) 常数时间**\n- **O(log n) 对数时间**\n- **O(n) 线性时间**\n- **O(n log n) 线性对数时间**\n- **O(n^2) 平方时间**\n- **O(2^n) 指数时间**\n- **O(n!) 阶乘时间**\n  现在我还是不会算一些循环的时间复杂度\n\n","categories":["note"]},{"title":"金工实习","url":"/archives/15058/","content":"\n我在大二转入了自动化专业，金工实习对我来说不单是一门课程，因为我对机械加工这一块非常感兴趣，这种兴趣应该是从小时候玩玩具可拆东西开始的。\n\n一次一次的拆卸组装玩具和一些电器让我想自己动手去做一些东西，家中凡是买来的玩具和一些容易拆卸的电器，无一是没有被我拆过的。最早的大概是玩具枪，记得小时候玩的五块钱一个的玩具手枪有点劣质但是威力并不算小，有个缺点就是气缸和扳机之间的部分容易变形，导致玩具枪报废，还找不到单卖气缸和扳机的，我就想着能不能把气缸和扳机换成金属部件。延长玩具枪的使用寿命。\n\n大二终于有了尝试机械加工的机会，每节金工实习我都听的很认真，操作也是非常上心，争取操作机会，目前金工实习才上了一点，所有实践内容大概就是下面这些\n\n- **[车工](#1)**\n\n- **[3D打印](#2)**\n\n- **钳工**\n\n- **激光**\n\n- **铸造**\n\n- **锻压**\n\n- **焊接**\n\n- **铣削**\n\n### **车工**<a id = \"1\"></a>\n\n先学的就是车工，我们学了普通卧式车床和数控车床的基本操作。**普通卧式车床**的操作，我们课上用的是塑料件，第一节课是老师讲完车床的基本操作之后给演示车一个小阶梯轴，在第一节课老师就给了我们组操作机会，我感觉很幸运。第二次去上课就是让我们每个组都车那个演示的小阶梯轴，第一次是我们三个人每人操作一步，但是车出之后零件的误差很大，能差上个2毫米还多。我们分析了其中的原因，应该是每次往里进刀的时候都重新读数导致的误差。\n\n当时时间还很充足，我提出一个人单独车一个零件。我是第一个操作的，这次我从刚开始读数后一直加着数算，没有重新读数，车好零件之后用游标卡尺测量，肉眼看到零刻度线是正对着主尺上的刻度线的，误差很小，但是后面的那个倒角没有车。这次没有在工料上划线，导致车出来的边缘有点翘边，这次还忘了车端面。\n\n**数控车床**实操的东西不多，学习了简单的对刀，还了解了一点编程。不过刚开始看到数控车床的时候看到操作面板上那么多的按钮真的不知所措，最后只是演示了一下一个工件的加工，并没有让我们实际动手去操作。\n\n### **3D打印**<a id = \"2\"></a>\n\n这个恰逢国庆假期调课，是早上八点的课，我一觉醒来已经八点十几了，匆匆忙忙赶到教室去上课，差点以为要完蛋了，因为金工实习不让我们迟到。不过老师很好，给了我机会，让我签到了。第一节课我们讲的是CATIA建模，教了一些基本操作，好在我之前在SolidWorks里面学习建模吊钩的时候都学过了这些简单的基本操作。\n\n第二次去教室让我们每人带一个U盘，存放我们自己建的模型，下节课用于打印。下午去了3D打印实训室，我中午挑时间学着建模了CS2的骷髅匕首，我感觉这把刀的设计很有美感，想打印出来玩一玩。但是打印的时候总是先两边翘边，然后就从底板上脱落了，试了好多次都不行，就让别人先打印了，结果我们这台机器到最后只有一个底面是圆的成功了。\n\n<img src=\"https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPZo36dvn0yOP782SvegFq0UCCN0oAACFh0AAmyk-FbOgg7t1iS9ZjYE.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n<img title=\"\" src=\"https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPlo36gIgtOQasiCCTjTbTYHQWVULQACGR0AAmyk-FYLOtJJiHfI9TYE.png\" alt=\"\" data-align=\"center\">\n\n下节课尝试一下立着打印，把与底板的接触面积减小，减小因温度降低的收缩量\n","categories":["note"]}]