[{"title":"数字电子技术学习及思考记录","url":"/archives/39715/","content":"\n# 一、数制和编码\n常用的几种进制：\n\n- 二进制(Binary)\n- 八进制(Octal)\n- 十进制(Decimal)\n- 十六进制(Hexadecmial)\n\n| 二进制 |八进制 | 十进制|十六进制|\n|:-----:|:-----:|:-----:|:-----:|\n|  0000 |   0   |   0   |    0  |\n|  0001 |   1   |   1   |    1  |\n|  0010 |   2   |   2   |    2  |\n|  0011 |   3   |   3   |    3  |\n|  0100 |   4   |   4   |    4  |\n|  0101 |   5   |   5   |    5  |\n|  0110 |   6   |   6   |    6  |\n|  0111 |   7   |   7   |    7  |\n|  1000 |  10   |   8   |    8  |\n|  1001 |  11   |   9   |    9  |\n|  1010 |  12   |  10   |    A  |\n|  1011 |  13   |  11   |    B  |\n|  1100 |  14   |  12   |    C  |\n|  1101 |  15   |  13   |    D  |\n|  1110 |  16   |  14   |    E  |\n|  1111 |  17   |  15   |    F  |\n|  ..   |  ..   |  ..   |   ..  |\n\n## 进制转换\n各种不同的数制之间可以相互转换\n\n### 1.二进制/八进制/十六进制相互转换\n- 八进制的每一位可以由三位二进制数字来表示\n- 十六进制的每一位可以由四位二进制数字表示\n\n可以将二进制三个或两个对应为一组，对应八进制或十六进制中的一位数字\n\n### 2.其他进制转十进制\n以下面这个二进制数为例\n$$101.11$$\n\n|  $1$  |  $0$  |  $1$  |  $.$  |  $1$    |  $1$    |\n|:-----:|:-----:|:-----:|:-----:|:-------:|:-------:|\n|  $4$  |  $2$  |  $1$  | $dot$ | $0.5$   | $0.25$  |\n|  $2^2$|  $2^1$|  $2^0$| $dot$ | $2^{-1}$| $2^{-2}$|\n|  $N^2$|  $N^1$|  $1$  | $dot$ | $N^{-1}$| $N^{-2}$|\n\n十进制数=\n$$1*2^2+0*2^1+1*1+1*2^{-1}+1*2^{-2} = 5.75$$\n\n### 3.十进制数转其他进制\n$10.375$转换成二进制:\n\n小数点之前：连续除以2取余数直到整数部分为零\n\n- 第一次：0  最低位\n- 第二次：1    ^\n- 第三次：0    | \n- 第四次：1    |\n- 第五次：0  最高位\n\n小数点之后：连乘2取整直到小数部分为零\n\n- 第一次：0 (0.75)\n- 第二次：1 (1.45)\n- 第三次：0 (0.90)\n- 第四次：1 (1.80) <<<|\n- 第五次：1 (1.60) \n- 第六次：1 (1.20) \n- 第七次：0 (0.40) \n- 第八次：0 (0.80) <<<|                     \n\n无法使小数部分归零,需限制精度取值\n\n小数部分先算出来的是高位，从上往下写\n$$01010.0101110……$$\n这里算的保留了最高位的零，因为我在C语言中把一个十进制整数转换成二进制字符串的时候发现这样算最高位始终会是一个零，这里提醒我注意倒序字符串之前要把最高位换成字符串结束符`\\0`\n\n## 几种常见编码\n- BCD(Binary Coded Decmial)码\n  - 8421 BCD码\n  - 5421 BCD码\n  - 2421 BCD码\n  - 余3码\n- 格雷码\n- ASCII\n- 汉明码\n- 奇偶数校验码\n\n# 二、逻辑代数\n均采用正逻辑\n\n- 非(NOT)\n- 与(AND)\n- 与非(NAND)\n- 或(OR)\n- 或非(NOR)\n- 异或(XOR)\n- 同或(XNOR)\n\n## 1.基础逻辑运算及其真值表\n### 1.非(NOT)\n对输入取反\n$$L = \\overline{A}$$\n\n| 输入(A)  | 输出(L) |\n|:--------:|:------:|\n|     0    |    1   |\n|     1    |    0   |\n\n### 2.与(AND)\n只有输入均为1时输出1\n$$L = A \\cdot B = AB$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    1   |\n\n### 3.与非(NAND)\n对与取反\n$$L = \\overline{A \\cdot B }= \\overline{AB}$$\n\n - [ ] 上次玩图灵完备这个游戏说是能由与非门组成其他所有逻辑门，等学完逻辑门就单独写一篇\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    0   |\n\n### 4.或(OR)\n输入中有1时输出1\n$$L = A + B$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    1   |\n\n### 5.或非(NOR)\n对或取反\n$$L = \\overline{A + B}$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    0   |\n\n### 6.异或(XOR)\n只输入一个1时输出1，比`OR`少一个全为1\n$$L = A \\overline{B} + \\overline{A} B = A \\oplus B$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    0   |\n|     0   |     1   |    1   |\n|     1   |     0   |    1   |\n|     1   |     1   |    0   |\n\n### 7.同或(XNOR)\n输入全相同时输出1，比`AND`多一个输入全为0\n$$L = AB + \\overline{A} \\overline{B} = A \\odot B = \\overline{A \\oplus B}$$\n\n| 输入(A) | 输入(B) | 输出(L) |\n|:-------:|:-------:|:------:|\n|     0   |     0   |    1   |\n|     0   |     1   |    0   |\n|     1   |     0   |    0   |\n|     1   |     1   |    1   |\n\n### 小结\n- $NAND = \\overline{AND}$\n- $NOR = \\overline{OR}$\n- $XNOR = \\overline{NOR}$\n\n构造一个XOR：\n\n```mermaid\n---\nconfig: \n    theme: neutral\n    layout: dagre\n\n---\nflowchart LR\n    in1[\"输入1\"]\n    in2[\"输入2\"]\n    OR[\"OR\"]\n    AND[\"AND\"]\n    NAND[\"NAND\"]\n    out[\"输出\"]\n\n        in1-->OR\n        in2-->OR\n        in1-->NAND\n        in2-->NAND\n        OR-->AND\n        NAND-->AND\n        AND-->out\n\n```","categories":["note"]},{"title":"Optimization","url":"/archives/21457/","content":"# 最优化理论学习笔记\n目的：\n找到解决问题的最佳方法\n\n问题分类：\n\n- 函数极值$f(x)$：静态优化\n- 泛函极值$f(u+v)$：动态优化\n\n## 一、正定矩阵(Positive Matrix)\n方阵$A$对任意一个非零向量$\\mathbf{x}$，总是$x^TAx>0$。$A$特征值全为正数。\n\n### 判断一个矩阵是否为正定矩阵\n- 判断特征值是否全为正数  $\\det(\\lambda\\mathbf{I}-\\mathbf{A})=0$\n- 顺序主子式全大于零\n\n## 二、海塞矩阵(Hessian Matrix)\n$$\\nabla^2f(\\mathbf{x})=\\begin{bmatrix}\n    \\dfrac{\\partial^2 f}{\\partial x_1^2} & \\dfrac{\\partial^2 f}{\\partial x_1 \\partial x_2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\n    \\dfrac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\dfrac{\\partial^2 f}{\\partial x_2^2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    \\dfrac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\dfrac{\\partial^2 f}{\\partial x_n \\partial x_2} & \\cdots & \\dfrac{\\partial^2 f}{\\partial x_n^2} \\\\\n\\end{bmatrix}$$\n\n## 三、求多元函数极值\n### 1.求出驻点\n对多元函数$f$求一阶偏导，让它等于0求出驻点\n\n$$\\dfrac{\\partial f}{\\partial x}=\\begin{pmatrix}\n   \\dfrac{\\partial f}{\\partial x_1}\\\\\n   \\dfrac{\\partial f}{\\partial x_2}\\\\\n   \\vdots\\\\\n   \\dfrac{\\partial f}{\\partial x_n}\\\\\n\\end{pmatrix}=0$$\n\n### 2.判断是不是极值点\n驻点可能会有多个，假设下面是其中一个驻点\n\n$$x=\\begin{pmatrix}\n   x_1^*\\\\ \n   x_2^*\\\\ \n   \\vdots\\\\\n   x_n^*\\\\ \n\\end{pmatrix}$$\n\n将其带入到海塞矩阵中，判断海塞矩阵的正负定性。\n\n- 海塞矩阵正定，该点是极小值点\n- $f(x)$ 的极大值是 $-f(x)$ 的极小值\n\n求极值：\n$$f(x)=x^4+8x^3+22x^2+24x$$\n\n\n\n## 四、凸集和凸函数\n### 1.凸集\n**定义** ：$D\\subset \\mathbb{R}^n，\\forall x,y \\in D，\\forall \\lambda \\in[0,1]满足\\lambda x(1-\\lambda)y\\in D$，称D为凸集合\n\n**特点** ：即内部无洞，边缘无内凹，任意两点间的连线仍然在集合内部\n\n**性质** : \n\n- 若$\\mathcal{D}$，$\\mathcal{A}$都为凸集，则$\\mathcal{D} \\bigcap \\mathcal{A}$，仍为凸集\n- \n\n**常见的凸集** \n$\\alpha \\in \\mathbb{R}^n$\n\n- **超平面** ：$H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x=b \\right \\}$\n- **半空间（闭）** ：$H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x<=b \\right \\}，H=\\left \\{x \\in \\mathbb{R}^n | \\alpha^T x>=b \\right \\}$\n- **半空间（开）** ：半空间（闭）去掉$\\alpha^T x=b$\n\n对与上面这三种的证明方法一致，这里以超平面为例：\n$$\\alpha \\left [\\lambda x + (1-\\lambda)y \\right ] = b(\\lambda + 1 - \\lambda) = b$$上面简单证明了超平面为凸集\n\n证明$\\mathcal{L}=\\left \\{ x\\in\\mathcal{R}^n|x=x_0+\\lambda d \\right\\}$，为凸集，$d,x_0$是给定非零向量, $\\lambda$为任意实数，其证明方法也是与上面一致的，只需要将数据带入就行。\n\n### 2.凸函数\n","categories":["note"]},{"title":"GCC基本使用","url":"/archives/21724/","content":"\n# 一.单个文件编译\n\n```bash\ngcc -v -Wall xxx.c -o xxx\n```\n\n- `-Wall` 在编译时对一些常见错误，潜在问题给出警告，方便发现问题，修正代码\n- `-o` **output** 指定编译生成的文件名\n    - 可以顺便指定目录\n- `-v` 列出一些详细信息，当编译出错时会非常有用\n    - 搜寻**头文件（header files）** 和 **库文件（libraries）**的目录\n    - 用于链接的**目标文件（object files）**和**库文件（libraries）**\n\n# 二.多个文件编译\n\n## 1.独立编译\n\n每个文件编译后生成一个 **目标文件（object file）** ，而不产生可运行文件，产生对应的`.O`或者`.obj`文件,\n\n**独立编译**\n\n```bash\ngcc -Wall -c xxx.c\n```\n`-c`产生相应的目标文件，这一步同样可以用`-o`参数指定文件名，否则与源文件同名\n\n## 2.链接\n\n所有的目标文件通过连接器(linker)链接在一起，产生一个独立的可运行文件。\n\n**链接**\n```bash\ngcc xxx.o yyyy.o -o Name\n```\n对于较大的工程，将所有源码写在一个源文件中每次修改重新编译很费时。\n这时候需要将源文件模块化编程，每次只需要重新编译修改过的部分.\n### 2.1链接顺序\n\ngcc无需指定链接顺序，对较老的编译器，有可能需要指定顺序，调用函数者放在前，定义函数者放在后。\n\n## 3.重编译重链接\n\n对发生改变的源文件重新编译，再重新链接\n\n# 三.链接外部库\n\n## 1.链接外部库的方式\n```bash\ngcc -Wall main.c /usr/lib/libm.a -o xxx\n```\n绝对路径链接目标库`libm.a`\n\n```bash\ngcc -Wall main.c -lNAME -o xxx\ngcc -Wall main.c /usr/lib/libm.a -o xxx //与下面作用相同\ngcc -Wall main.c -lm io xxx\n```\n对于库文件`libNAME.a`,可以用`-lNAME`链接 \n\n```bash\ngcc -Wall main.c -L$LibPath -lNAME\n```\n\n## 搜索路径\n\n`-I`和`-L`参数指定搜索路经\n\n- `-I`指定头文件搜索目录\n- `-L`指定库文件搜索目录\n\n# 使用`ar`创建一个库\n\n```bash\nar cr libNAME.a file1.o file2.o ... filen.o\n```\n`cr`\n\n- `c` create 创建\n- `r` replace 替换\n\n```bash\nar t libNAME.a\n```\n列出`libNAME.a`里的目标文件\n\n## 创建一个库`libTEST.a`并使用\n### 1.创建头文件和源码\n\n`libTEST.h`,`func1.c`,`func2.c`,`main.c`\n\n\n```c:func1.c\n//func1.c\n#include \"libTEST.h\"\nint func1(int x, int y){\n    return (x+y);\n}\n```\n```c:func2.c\n//func2.c\n#include <stdio.h>\nvoid func2(int x){\n    printf(\"Result = %d\", x);\n}\n```\n```c:libTEST.h\n//libTEST.h\n#ifndef __LIBTEST_H__\n#define __LIBTEST_H__ \n\nint func1(int x, int y);\nvoid func2(int x);\n\n#endif \n```\n```c:main.c\n//main.c\n#include \"libTEST.h\"\nint main(){\n    int i;\n    i = func1(1, 2);\n    func2(i);\n}\n```\n### 2.创建目标文件\n\n```bash\ngcc -Wall -c func1.c func2.c\n```\n此时产生目标文件`func1.o`,`func2.o`\n\n### 3.将目标文件创建成库\n\n```bash\nar cr libTEST.a func1.o func2.o\n```\n生成了库文件`libTEST.a`\n\n### 4.使用库文件\n在编译时链接刚刚创建的库`libTEST.a`，要将`main.c`放在`libTEST.a`之前\n\n!⭕!库文件`.a`为二进制文件。`main.c`调用`libTEST.a`，放在前面。\n```bash\ngcc -Wall main.c libTEST.a\n```\nOR\n添加搜索库路径参数\n```bash\ngcc -Wall main.c -L. -lTEST\n```\n运行输出文件，程序结果为`3`","categories":["note"]},{"title":"十月周末总结","url":"/archives/19160/","content":"\n## 第一次周末总结 \n\n### 10月6 - 10月12\n\n6号是中秋节，10月1 — 10月8是国庆和中秋假期，整个国庆假期都在学校，每天打打CS2。国庆假期升级了电脑的内存，换了两根24G DDR5 5600MHz的内存条，原来的是两根8G实在是有点不够用。SW开个模型就要报内存可使用内存不够用。刚开始还计划假期几天出去玩玩，比如去龙潭山，朱雀山看看吉林的秋景。最后这八天都没有出去走一走。\n\n中秋节晚上和舍友邓一块去了河南街的福源馆，买了几个月饼，说实话这个月饼中规中矩，吃起来没有什么特别的，就是一种很熟悉的味道，但是挺贵的，最便宜的六块五一个。我买了两个六块五的，一个八块的，到宿舍给了舍友一个。从9号开始上课到12号，周六补了10月八号的课。\n\n### 学习方面\n\n#### 物理 \n\n假期补了前面的一点作业，是关于光的偏振的，自然光光强$I_0$透过偏振片后光强变为原来的一半$I_1=I_0/2$，产生的线偏振光与的振动方向与另一个偏振片的偏振化方向夹角$\\alpha$，则透射光的光强$I = I_1\\cos^2\\alpha$\n上面这个就是 **（马吕斯定律）** 证明：是将入射光的光矢量振幅$E_0$分成 **垂直** 和 **平行** 于偏振片偏振化方向的分量 $E_0\\sin\\alpha$ 和 $E_0\\cos\\alpha$ ，光强与振幅的二次方成正比，$\\begin{gather*}\\frac{I}{I_1}=\\frac{(E_0\\cos\\alpha)^2}{E_0^2}\\end{gather*}$ \n\n上课新学习了电场强度通量，和高斯定理。电场强度通量在书中是这么说的： **通过电场中任一给定面积的电场线根数，称为通过该面积的电场强度通量,用$\\Phi_e$表示**。感觉这是一种很好理解 **高斯定理** 的方式。 **高斯定理** 的表述： **穿过任意闭合曲面的电场强度通量，等于曲面内所包围的全部电荷的电荷量的代数和除以$\\varepsilon_0$**。\n\n$\\begin{gather*}\n\\Phi_e=\\oint_S E\\cdot \\,d\\mathrm{S}=\\frac{1}{\\varepsilon_0}\\sum_{i=1}^{n} q_i\n\\end{gather*}$\n\n然后又学了电势差，电势，上课算了一些常见的物理模型：（下次补充）\n\n#### 51单片机\n\n- [x] 点亮一颗LED，LED流水灯，独立按键控制LED状态，独立按键控制LED移位\n- [x] 数码管静态显示，动态显示\n\n在控制LED的编程过程中用到的较多的是\n- 2进制和16进制转换\n- 按位取反\n- 延时\n\n数码管操作起来比LED复杂许多，掌握74HC138译码器使用实现数码管的位选，74HC245控制段选，对于动态显示要消影。\n\n#### 电路原理\n\n\n#### 最优化理论\n目的：\n找到解决问题的最佳方法\n问题分类：\n- 函数极值$f(x)$：静态优化\n- 泛函极值$f(u+v)$：动态优化\n\n\n#### 体育课3200M\n跑了 13'28\"","categories":["life"]},{"title":"Latextest","url":"/archives/10000/","content":"# latex 希腊字母表\n|Latex     |小写符号   | Latex       |大写符号    |\n|:--------:|:--------:|:----------:|:----------:|\n|`\\alpha`  |$\\alpha$  |`\\mathrm{A}`|$\\mathrm{A}$|\n|`\\beta`   |$\\beta$   |`\\mathrm{B}`|$\\mathrm{B}$|\n|`\\gamma`  |$\\gamma$  |`\\Gamma`    |$\\Gamma$    |\n|`\\delta`  |$\\delta$  |`\\Delta`    |$\\Delta$    |\n|`\\zeta`   |$\\zeta$   |`\\Zeta`     |$\\Zeta$     |\n|`\\epsilon`|$\\epsilon$|`\\mathrm{E}`|$\\mathrm{E}$|\n|`\\eta`    |$\\eta$    |`Eta`       |$\\Eta$      |\n","categories":["note"]},{"title":"Hello World","url":"/archives/16107/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"C语言初识之猜数游戏","url":"/archives/26716/","content":"\n转入自动化专业之后以后的学习会用到C语言，本来自动化专业大一就学过 ***《C语言程序设计》*** ，所以我需要对这一门课程进行补修。刚好我也对这方面感兴趣，顺便提前学习了一点点，现在我自学的基本都是看菜鸟教程和一点点实践出来的。突发奇想写个猜数字的游戏，很简陋，只有命令行界面。这个文章简要记录了我这个程序的变化及想法的实现。\n\n我刚开始是只写了能运行一次的，也就是下面这个流程，但是玩完一次还得再去运行，不能直接再次开始游戏，想再玩的话很麻烦，还得再打开一次。然后就想办法让他能再次运行，我的想法是通过一个`while`循环来实现，先定义了循环变量`r`并初始化为2，然后输出 **游戏开始[1]** 和 **退出选项[2]** 引导玩家去输入选择开始或者退出游戏，当输入`1`就开始游戏，这里直接选择了小于等于1开始循环。然后初始化 **随机数发生器** ，从1-100选择一个数作为这次游戏的答案，定义并初始化用于记录尝试次数的变量`n = 1`，因为就算第一次输入正确也是尝试了1次，定义用于玩家输入的变量`x`，告知游戏规则，由玩家输入数字，输入不等于答案时告知大小关系，变量`n`加1，告知玩家再次尝试，这是为了玩家清楚现在的状态，不是死机。当输入等于答案时退出这层循环，然后输出尝试次数和正确答案，询问是否再玩一次，再次由玩家输入到变量`r`\n\n```mermaid\n---\nconfig:\n    theme: neutral\n    layout: dagre\n\n---\nflowchart TD\n    A[\"猜数游戏\"]\n    answer[\"随机生成答案\"]\n    input[\"输入\"]\n    false[\"记录尝试次数，告知与答案大小关系\"]\n    true[\"输出尝试次数，正确答案\"]\n    stop[\"结束游戏\"]\n    A -->|告知规则| answer\n    answer --> input\n    input --> |猜错| false\n    input --> |猜对| true\n    false --> input\n    true --> stop\n```\n\n修改后的流程图和代码是这样的，算是一个很简单的小游戏了\n\n```mermaid\n---\nconfig:\n  theme: neutral\n  layout: dagre\n\n---\nflowchart TD\n    A[\"猜数游戏\"] -->|输入1| C(\"随机生成答案\")\n    A -->|输入2| D(\"结束游戏\")\n    C --> E(\"猜数\")\n    E -->|猜对| F(\"尝试次数，正确答案\")\n    E -->|猜错| G(\"告知与答案大小关系\")\n    G -->|记录尝试次数| E\n    F --> A\n    R(告知规则) --> A\n```\n\n\n\n```c\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\nint main()\n{\n    int r = 2;\n    printf(\"\\tGuess NUMBER game\\t\\n\\n\\t    [1]Start\\t\\n\\n\\t    [2]EXIT\\t\\n\");\n    scanf(\"%d\", &r);\n    while( r <= 1 ) // 开始游戏\n    {\n        srand((unsigned int)time(NULL));\n        int answer = rand() % 101 + 1; // 从1-100随机选取一个数字\n        int x = 0;\n        int n = 1; // 用于记录尝试次数的变量\n        printf(\"\\tGuess a NUMBER from 1 to 100\\t\\n\\nI'll tell you whether IT is bigger or smaller\\nin comparison with the NUMBER i selected\\n\\n\");\n        printf (\"Enter Your ANSWER: \");\n        scanf(\"%d\", &x);\n        while(x != answer) // 猜错开始循环\n        {\n            if(x < answer) // 输入小于答案\n            {\n                printf(\"Your answer is Smaller\\n\");\n            }\n            else // 输入大于答案\n            {\n                printf(\"Your answer is Bigger\\n\");\n            }\n            printf(\"Try again: \");\n            n++;\n            scanf(\"%d\", &x);\n        }\n        printf(\"You've tried %d times, the Answer is %d\\n\", n, answer);\n        printf(\"[1] PLAY AGAIN\\n[2] EXIT.....\\n\");\n        scanf(\"%d\", &r);\n    }\n    return 0;\n}\n```\n\n在 ***《软件技术基础》*** 这门刚开始学的课程中老师讲的算法的**时间复杂度**，讲了**大O表示法（Big O Notation）**，举了一些例子\n\n- **O(1) 常数时间**\n- **O(log n) 对数时间**\n- **O(n) 线性时间**\n- **O(n log n) 线性对数时间**\n- **O(n^2) 平方时间**\n- **O(2^n) 指数时间**\n- **O(n!) 阶乘时间**\n  现在我还是不会算一些循环的时间复杂度\n\n","categories":["note"]},{"title":"金工实习","url":"/archives/15058/","content":"\n我在大二转入了自动化专业，金工实习对我来说不单是一门课程，因为我对机械加工这一块非常感兴趣，这种兴趣应该是从小时候玩玩具可拆东西开始的。\n\n一次一次的拆卸组装玩具和一些电器让我想自己动手去做一些东西，家中凡是买来的玩具和一些容易拆卸的电器，无一是没有被我拆过的。最早的大概是玩具枪，记得小时候玩的五块钱一个的玩具手枪有点劣质但是威力并不算小，有个缺点就是气缸和扳机之间的部分容易变形，导致玩具枪报废，还找不到单卖气缸和扳机的，我就想着能不能把气缸和扳机换成金属部件。延长玩具枪的使用寿命。\n\n大二终于有了尝试机械加工的机会，每节金工实习我都听的很认真，操作也是非常上心，争取操作机会，目前金工实习才上了一点，所有实践内容大概就是下面这些\n\n- **[车工](#1)**\n\n- **[3D打印](#2)**\n\n- **钳工**\n\n- **激光**\n\n- **铸造**\n\n- **锻压**\n\n- **焊接**\n\n- **铣削**\n\n### **车工**<a id = \"1\"></a>\n\n先学的就是车工，我们学了普通卧式车床和数控车床的基本操作。**普通卧式车床**的操作，我们课上用的是塑料件，第一节课是老师讲完车床的基本操作之后给演示车一个小阶梯轴，在第一节课老师就给了我们组操作机会，我感觉很幸运。第二次去上课就是让我们每个组都车那个演示的小阶梯轴，第一次是我们三个人每人操作一步，但是车出之后零件的误差很大，能差上个2毫米还多。我们分析了其中的原因，应该是每次往里进刀的时候都重新读数导致的误差。\n\n当时时间还很充足，我提出一个人单独车一个零件。我是第一个操作的，这次我从刚开始读数后一直加着数算，没有重新读数，车好零件之后用游标卡尺测量，肉眼看到零刻度线是正对着主尺上的刻度线的，误差很小，但是后面的那个倒角没有车。这次没有在工料上划线，导致车出来的边缘有点翘边，这次还忘了车端面。\n\n**数控车床**实操的东西不多，学习了简单的对刀，还了解了一点编程。不过刚开始看到数控车床的时候看到操作面板上那么多的按钮真的不知所措，最后只是演示了一下一个工件的加工，并没有让我们实际动手去操作。\n\n### **3D打印**<a id = \"2\"></a>\n\n这个恰逢国庆假期调课，是早上八点的课，我一觉醒来已经八点十几了，匆匆忙忙赶到教室去上课，差点以为要完蛋了，因为金工实习不让我们迟到。不过老师很好，给了我机会，让我签到了。第一节课我们讲的是CATIA建模，教了一些基本操作，好在我之前在SolidWorks里面学习建模吊钩的时候都学过了这些简单的基本操作。\n\n第二次去教室让我们每人带一个U盘，存放我们自己建的模型，下节课用于打印。下午去了3D打印实训室，我中午挑时间学着建模了CS2的骷髅匕首，我感觉这把刀的设计很有美感，想打印出来玩一玩。但是打印的时候总是先两边翘边，然后就从底板上脱落了，试了好多次都不行，就让别人先打印了，结果我们这台机器到最后只有一个底面是圆的成功了。\n\n<img src=\"https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPZo36dvn0yOP782SvegFq0UCCN0oAACFh0AAmyk-FbOgg7t1iS9ZjYE.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n<img title=\"\" src=\"https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPlo36gIgtOQasiCCTjTbTYHQWVULQACGR0AAmyk-FYLOtJJiHfI9TYE.png\" alt=\"\" data-align=\"center\">\n\n下节课尝试一下立着打印，把与底板的接触面积减小，减小因温度降低的收缩量\n","categories":["note"]}]