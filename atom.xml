<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pixel&#39;s Blog</title>
  <icon>https://remermagors.github.io/images/logo.svg</icon>
  <subtitle>Step Forward</subtitle>
  <link href="https://remermagors.github.io/atom.xml" rel="self"/>
  
  <link href="https://remermagors.github.io/"/>
  <updated>2025-11-06T16:05:24.282Z</updated>
  <id>https://remermagors.github.io/</id>
  
  <author>
    <name>Pixel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字电子技术学习及思考记录</title>
    <link href="https://remermagors.github.io/archives/39715/"/>
    <id>https://remermagors.github.io/archives/39715/</id>
    <published>2025-10-23T10:11:16.000Z</published>
    <updated>2025-11-06T16:05:24.282Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="hljs mermaid">---config:  theme: neutral  layout: tidy-tree---mindmaproot((数字电子技术))  basic1(数码与码制)  basic2&#123;&#123;逻辑代数基础&#125;&#125;  basic3))门电路((  basic4&#123;&#123;组合逻辑电路&#125;&#125;  basic5[半导体存储电路]  basic6(时序逻辑电路)  basic7)脉冲波形的产生和整形电路(</code></pre><hr /><h1 id="一数制和码制">一、数制和码制</h1><pre><code class="hljs mermaid">---config:  theme: neutral  layout: tidy-tree---mindmaproot((数制和码制))  1&#123;&#123;数制&#125;&#125;    1)常用数制(      1(数制间的相互转换)  2&#123;&#123;码制&#125;&#125;    1)常用编码(      1(BCD)        1)8421BCD(        2)5421BCD(        3)2421BCD(        4)余3码(      2(ASCII)      3(格雷码)</code></pre><p>常用的几种进制:</p><ul><li>二进制(Binary)</li><li>八进制(Octal)</li><li>十进制(Decimal)</li><li>十六进制(Hexadecmial)</li></ul><table><thead><tr><th style="text-align: center;">二进制</th><th style="text-align: center;">八进制</th><th style="text-align: center;">十进制</th><th style="text-align: center;">十六进制</th></tr></thead><tbody><tr><td style="text-align: center;">0000</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0001</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0010</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">0011</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">0100</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">0101</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">0110</td><td style="text-align: center;">6</td><td style="text-align: center;">6</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;">0111</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">1000</td><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">8</td></tr><tr><td style="text-align: center;">1001</td><td style="text-align: center;">11</td><td style="text-align: center;">9</td><td style="text-align: center;">9</td></tr><tr><td style="text-align: center;">1010</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">A</td></tr><tr><td style="text-align: center;">1011</td><td style="text-align: center;">13</td><td style="text-align: center;">11</td><td style="text-align: center;">B</td></tr><tr><td style="text-align: center;">1100</td><td style="text-align: center;">14</td><td style="text-align: center;">12</td><td style="text-align: center;">C</td></tr><tr><td style="text-align: center;">1101</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td><td style="text-align: center;">D</td></tr><tr><td style="text-align: center;">1110</td><td style="text-align: center;">16</td><td style="text-align: center;">14</td><td style="text-align: center;">E</td></tr><tr><td style="text-align: center;">1111</td><td style="text-align: center;">17</td><td style="text-align: center;">15</td><td style="text-align: center;">F</td></tr><tr><td style="text-align: center;">..</td><td style="text-align: center;">..</td><td style="text-align: center;">..</td><td style="text-align: center;">..</td></tr></tbody></table><hr /><h2 id="进制转换">进制转换</h2><p>各种不同的数制之间可以相互转换</p><h3id="二进制八进制十六进制相互转换">1.二进制/八进制/十六进制相互转换</h3><ul><li>八进制的每一位可以由三位二进制数字来表示</li><li>十六进制的每一位可以由四位二进制数字表示</li></ul><p>可以将二进制三个或两个对应为一组,对应八进制或十六进制中的一位数字</p><h3 id="其他进制转十进制">2.其他进制转十进制</h3><p>以下面这个二进制数为例 <spanclass="math display">\[101.11\]</span></p><table><thead><tr><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(.\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(4\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(dot\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0.5\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0.25\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(2^2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2^1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2^0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(dot\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2^{-1}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2^{-2}\)</span></td></tr><tr><td style="text-align: center;"><spanclass="math inline">\(N^2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(N^1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(dot\)</span></td><td style="text-align: center;"><spanclass="math inline">\(N^{-1}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(N^{-2}\)</span></td></tr></tbody></table><p>十进制数= <span class="math display">\[1 \times 2^2+0 \times 2^1+1\times 1+1 \times 2^{-1}+1 \times 2^{-2} = 5.75\]</span></p><h3 id="十进制数转其他进制">3.十进制数转其他进制</h3><p><span class="math inline">\(10.375\)</span>转换成二进制:</p><p>小数点之前:连续除以2取余数直到整数部分为零</p><ul><li>第一次:0 最低位</li><li>第二次:1 ^</li><li>第三次:0 |</li><li>第四次:1 |</li><li>第五次:0 最高位</li></ul><p>小数点之后:连乘2取整直到小数部分为零</p><ul><li>第一次:0 (0.75)</li><li>第二次:1 (1.45)</li><li>第三次:0 (0.90)</li><li>第四次:1 (1.80) &lt;&lt;&lt;|</li><li>第五次:1 (1.60)</li><li>第六次:1 (1.20)</li><li>第七次:0 (0.40)</li><li>第八次:0 (0.80) &lt;&lt;&lt;|</li></ul><p>无法使小数部分归零,需限制精度取值</p><p>小数部分先算出来的是高位, 从上往下写 <spanclass="math display">\[01010.0101110……\]</span>这里算的保留了最高位的零,因为我在C语言中把一个十进制整数转换成二进制字符串的时候发现这样算最高位始终会是一个零，这里提醒我注意倒序字符串之前要把最高位换成字符串结束符<code>\0</code></p><h2 id="几种常见编码">几种常见编码</h2><h3 id="bcdbinary-coded-decmial码">1. BCD(Binary Coded Decmial)码</h3><ul><li>8421 BCD码</li><li>5421 BCD码</li><li>2421 BCD码</li><li>余3码</li></ul><h3 id="格雷码">2. 格雷码</h3><ul><li>相邻两码之间只有一个数发生变化</li><li><span class="math inline">\(G_i\)</span>代表格雷码第<spanclass="math inline">\(i\)</span>位, <spanclass="math inline">\(B_i\)</span>代表二进制码第<spanclass="math inline">\(i\)</span>位<ul><li><span class="math inline">\(G_i = B_i \oplus B_{i+1}\)</span><ul><li>也就是说二进制码的每一位与其前一位异或之后就是格雷码</li></ul></li></ul></li></ul><table><thead><tr><th style="text-align: center;"><spanclass="math inline">\(G_4\)</span></th><th style="text-align: center;"><spanclass="math inline">\(G_3\)</span></th><th style="text-align: center;"><spanclass="math inline">\(G_2\)</span></th><th style="text-align: center;"><spanclass="math inline">\(G_1\)</span></th><th style="text-align: center;">\\</th><th style="text-align: center;"><spanclass="math inline">\(B_4\)</span></th><th style="text-align: center;"><spanclass="math inline">\(B_3\)</span></th><th style="text-align: center;"><spanclass="math inline">\(B_2\)</span></th><th style="text-align: center;"><spanclass="math inline">\(B_1\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">\\</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">\\</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">\\</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td><td style="text-align: center;">—–</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">\\</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><ul><li>格雷码具有对称性, <spanclass="math inline">\(n\)</span>位格雷码有<spanclass="math inline">\(2^{n-1}\)</span>个以<spanclass="math inline">\(1\)</span>开头的部分，这和卡诺图化简中圈出元素的数量是对应的</li><li><span class="math inline">\(n\)</span>位格雷码的后的<spanclass="math inline">\(n-1\)</span>位数, 是<spanclass="math inline">\(n-1\)</span>位格雷码的逆置(关于表中横线对称)</li></ul><h3 id="ascii">3. ASCII</h3><h3 id="汉明码">4. 汉明码</h3><h3 id="奇偶数校验码">5. 奇偶数校验码</h3><hr /><h2 id="机器数">⭕机器数</h2><p>一个数在计算机中以二进制的形式表示, 做高位是符号位，0为正，1为负，带符号位的机器数对应的真正数值是机器数的真值</p><h3 id="原码sign-magnitude-representation">1.原码（Sign-MagnitudeRepresentation)</h3><p>在原数值前加一位符号位构成及机器数</p><p>对于一个五位原码（有一位用来存储符号）, 其能表示的范围为<spanclass="math inline">\([-15,15]\)</span>即<spanclass="math inline">\([-2^4,2^4]\)</span>，共有<spanclass="math inline">\(2^5-1 = 31\)</span>个数</p><p><span class="math inline">\(\left. \begin{array}{lcl} 00000 \\ 10000\end{array} \right \} \text{两个均代表零}\)</span></p><h3 id="反码ones-complement">2.反码（One’s complement）</h3><ul><li>正数的反码是其本身（这也没变化啊, 还得再取一个名字？）</li><li>负数的反码符号位不变, 其余各位取反</li></ul><h3 id="补码twos-complement">3.补码（Two’s complement)</h3><ul><li>正数的补码是其本身</li><li>负数的补码是其反码加1</li></ul><hr /><h1 id="二逻辑代数">二、逻辑代数</h1><p>均采用正逻辑</p><pre><code class="hljs mermaid">---config:  theme: neutral  layout: tidy-tree---mindmaproot((逻辑代数))  A&#123;&#123;基础逻辑运算及其真值表&#125;&#125;    1)基本运算(      1(与 **AND** )      2(或 **OR** )      3(非 **NOT** )    2)由基本运算复合的常用运算(      1(与非 **NAND** )      2(或非 **NOR** )      3(同或 **XOR** )      4(异或 **XNOR** )</code></pre><h2 id="基础逻辑运算及其真值表">1.基础逻辑运算及其真值表</h2><ul><li>与(AND)</li><li>非(NOT)</li><li>与非(NAND)</li><li>或(OR)</li><li>或非(NOR)</li><li>异或(XOR)</li><li>同或(XNOR)</li></ul><h3 id="非not">1.非(NOT)</h3><p>对输入取反 <span class="math display">\[L = \overline{A}\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><h3 id="与and">2.与(AND)</h3><p>只有输入均为1时输出1 <span class="math display">\[L = A \cdot B =AB\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><h3 id="与非nand">3.与非(NAND)</h3><p>对与取反 <span class="math display">\[L = \overline{A \cdot B }=\overline{AB}\]</span></p><ul class="task-list"><li><label><inputtype="checkbox" />上次玩图灵完备这个游戏说是能由与非门组成其他所有逻辑门,等学完逻辑门就单独写一篇</label></li></ul><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><h3 id="或or">4.或(OR)</h3><p>输入中有1时输出1 <span class="math display">\[L = A + B\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><h3 id="或非nor">5.或非(NOR)</h3><p>对或取反 <span class="math display">\[L = \overline{A +B}\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><h3 id="异或xor">6.异或(XOR)</h3><p>只输入一个1时输出1, 比<code>OR</code>少一个全为1 <spanclass="math display">\[L = A \overline{B} + \overline{A} B = A \oplusB\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><h3 id="同或xnor">7.同或(XNOR)</h3><p>输入全相同时输出1, 比<code>AND</code>多一个输入全为0 <spanclass="math display">\[L = AB + \overline{A} \cdot \overline{B} = A\odot B = \overline{A \oplus B}\]</span></p><table><thead><tr><th style="text-align: center;">输入(A)</th><th style="text-align: center;">输入(B)</th><th style="text-align: center;">输出(L)</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><h3 id="小结">小结</h3><ul><li><span class="math inline">\(NAND = \overline{AND}\)</span></li><li><span class="math inline">\(NOR = \overline{OR}\)</span></li><li><span class="math inline">\(XNOR = \overline{NOR}\)</span></li></ul><p>构造一个XOR:</p><pre><code class="hljs mermaid">---config:     theme: base    layout: dagre---flowchart LR    in1[&quot;输入1&quot;]    in2[&quot;输入2&quot;]    OR[&quot;OR&quot;]    AND[&quot;AND&quot;]    NAND[&quot;NAND&quot;]    out[&quot;输出&quot;]        in1--&gt;OR        in2--&gt;OR        in1--&gt;NAND        in2--&gt;NAND        OR--&gt;AND        NAND--&gt;AND        AND--&gt;out</code></pre><h2 id="逻辑代数的基本运算">2.逻辑代数的基本运算</h2><table><thead><tr><th style="text-align: center;"><span class="math inline">\(0 \cdot A =0\)</span></th><th style="text-align: center;"><span class="math inline">\(A B = BA\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(1 \cdot A =A\)</span></td><td style="text-align: center;"><span class="math inline">\(A(BC) =(AB)C\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(A \cdot\overline{A} = 0\)</span></td><td style="text-align: center;"><span class="math inline">\((A+B)+C =A+(B+C)\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(A +\overline{A} = 1\)</span></td><td style="text-align: center;"><span class="math inline">\(A(B+C) = AB+ AC\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(A + 0 =A\)</span></td><td style="text-align: center;"><span class="math inline">\(A+BC =(A+C)(B+C)\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(A + 1 =1\)</span></td><td style="text-align: center;"></td></tr></tbody></table><h3 id="德摩根定律">德摩根定律</h3><p><span class="math inline">\(\overline{A+B} = \overline{A} \cdot\overline{B}\)</span></p><p><span class="math inline">\(\overline{A \cdot B} = \overline{A} +\overline{B}\)</span></p><ul><li>第一个公式右边 <strong>对与的输入取反</strong> 得到左边的<strong>或对输出取反</strong> 即 <strong>或非</strong></li><li>第二个公式右边 <strong>对或的输入取反</strong> 得到左边的<strong>与对输出取反</strong> 即 <strong>与非</strong></li></ul><h3 id="对偶原理">对偶原理</h3><p>在一个逻辑代数表达式中,<strong>同时进行一下两种替换</strong>（不改变运算顺序）:</p><ol type="1"><li>将所有的<code>·</code>(与)运算换成<code>+</code>(或)运算</li><li>将所有的<code>+</code>(或)运算换成<code>·</code>(与)运算</li><li><code>1</code>和<code>0</code>互换</li></ol><p>得到的新表达式就是原表达式的 <strong>对偶式</strong></p><ul><li>原表达式: <span class="math inline">\(F = 1 + (A + B \cdotC)\)</span></li><li>其对偶式: <span class="math inline">\(F_d = 0 \cdot [ A \cdot (B +C) ]\)</span><ul><li><code>·</code>换成了<code>+</code></li><li><code>+</code>换成了<code>·</code></li><li><code>1</code>换成了<code>0</code></li></ul></li></ul><p>得到的函数成为原函数的对偶函数</p><p><strong>对偶原理</strong> :如果一个逻辑恒等式成立,那么其对偶式也必然成立</p><p><strong>对偶原理为什么会成立?</strong></p><p>布尔代数的基本公理是对偶的:</p><ol type="1"><li><strong>交换律</strong><ul><li><span class="math inline">\(A + B = B + A\)</span></li><li><span class="math inline">\(A \cdot B = B \cdot A\)</span></li></ul></li><li><strong>分配律</strong><ul><li><span class="math inline">\(A + (B \cdot C) = (A + B) \cdot (A +C)\)</span></li><li><span class="math inline">\(A \cdot (B + C) = (A \cdot B) + (A \cdotC)\)</span></li></ul></li><li><strong>单位元</strong><ul><li><span class="math inline">\(A + 0 = A\)</span></li><li><span class="math inline">\(A \cdot 1 = A\)</span></li></ul></li><li><strong>互补律</strong><ul><li><span class="math inline">\(A + \overline{A} = 1\)</span></li><li><span class="math inline">\(A \cdot \overline{A} = 0\)</span></li></ul></li></ol><p>由其推出来的其他定理也应该是对称的</p><p><strong>常用的定理及其对偶式</strong>:</p><ul><li><span class="math inline">\(A + AB = A\)</span><ul><li>这个公式用集合视角很好理解, <span class="math inline">\(AB \subseteqA\)</span></li><li><span class="math inline">\(\begin{aligned}  &amp; A + AB\\  &amp; = A \cdot (1 + B) \\  &amp; = A  \end{aligned}\)</span></li></ul></li><li><span class="math inline">\(A \cdot (A + B) = A\)</span><ul><li>上面那个式子的对偶式, 很容易证明</li></ul></li><li><span class="math inline">\(A + \overline{A}C = A + C\)</span><ul><li><span class="math inline">\(\begin{aligned}  &amp; A(C + 1) + \overline{A}C \\  &amp; = AC + A + \overline{A}C \\  &amp; = A + C\end{aligned}\)</span></li></ul></li><li><span class="math inline">\(A \cdot (\overline{A} + C) = A \cdotC\)</span><ul><li>对于上面那个<span class="math inline">\(A + \overline{A}C = A +C\)</span>, 要是一时没想起来哪个证明方法可以证明其对偶式成立</li></ul></li></ul><p><span class="math inline">\(A + \overline{A}C = A + C\)</span>如果直接用逻辑门需要一个与门,一个或门，一个非门，而转化成等式右边只需要一个或门</p><h3 id="反演定理">反演定理</h3><p>与对偶定理很相似, 不过多了一步操作</p><p>在一个逻辑代数表达式中,<strong>同时进行一下两种替换</strong>（不改变运算顺序）:</p><ol type="1"><li>将所有的<code>·</code>(与)运算换成<code>+</code>(或)运算</li><li>将所有的<code>+</code>(或)运算换成<code>·</code>(与)运算</li><li><code>1</code>和<code>0</code>互换</li><li>对每个变量都取反</li></ol><p>得到的新函数是原函数的反函数（对输出取反）</p><p>其本质是对德摩根定理的推广</p><p><span class="math inline">\(\overline{A+B} = \overline{A} \cdot\overline{B}\)</span></p><p><span class="math inline">\(\overline{A \cdot B} = \overline{A} +\overline{B}\)</span></p><h2 id="卡诺图化简">3.卡诺图化简</h2><ul><li><strong>最小项</strong>: 一个与式中所有变量都出现,且每个变量只出现一次，以原变量或取非的形式出现，<spanclass="math inline">\(A\)</span> 出现过就不能再出现 <spanclass="math inline">\(\overline{A}\)</span>了，一个变量对应两种可能出现的形式，对于<spanclass="math inline">\(n\)</span>个变量，有<spanclass="math inline">\(2^n\)</span>个最小项</li><li><strong>逻辑相邻</strong>:两个项之间只有一个变量以原变量和取反的形式出现，其它变量均相同: <spanclass="math inline">\(ABC\)</span>和<spanclass="math inline">\(AB\overline{C}\)</span>,两式相加可消去发生变化的变量<span class="math inline">\(C\)</span>.</li></ul><p><span class="math display">\[\begin{array}{c|cccc}AB\backslash CD &amp; 00 &amp; 01 &amp; 11 &amp; 10 \\\hline00 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\01 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\11 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\10 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\end{array}\]</span></p><p>卡诺图中的变量的取值的排序要根据根据格雷码排列,保证表中物理相邻一定逻辑相邻</p><h3 id="从卡诺图化简逻辑表达式">从卡诺图化简逻辑表达式</h3><p>从表中圈出取值相同的项, 每次要尽可能圈的多, 保证逻辑相邻.</p><ol type="1"><li>圈1<ul><li>第一行和第四行的1</li><li>第一列和第四列的1</li></ul></li></ol><p><span class="math inline">\(F = \overline{B}D + B\overline{D} = B\oplus D\)</span>, 异或</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;hljs mermaid&quot;&gt;---
config:
  theme: neutral
  layout: tidy-tree
---
mindmap
root((数字电子技术))
  basic1(数码与码制)
  basic2&amp;#123;&amp;#</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimization</title>
    <link href="https://remermagors.github.io/archives/21457/"/>
    <id>https://remermagors.github.io/archives/21457/</id>
    <published>2025-10-15T09:16:28.000Z</published>
    <updated>2025-11-04T11:28:21.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最优化理论学习笔记">最优化理论学习笔记</h1><p>目的： 找到解决问题的最佳方法</p><p>问题分类：</p><ul><li>函数极值<span class="math inline">\(f(x)\)</span>：静态优化</li><li>泛函极值<span class="math inline">\(f(u+v)\)</span>：动态优化</li></ul><hr /><h2 id="一正定矩阵positive-matrix">一、正定矩阵(Positive Matrix)</h2><p>方阵<span class="math inline">\(A\)</span>对任意一个非零向量<spanclass="math inline">\(\mathbf{x}\)</span>，总是<spanclass="math inline">\(x^TAx&gt;0\)</span>。<spanclass="math inline">\(A\)</span>特征值全为正数。</p><h3 id="判断一个矩阵是否为正定矩阵">判断一个矩阵是否为正定矩阵</h3><ul><li>判断特征值是否全为正数 <spanclass="math inline">\(\det(\lambda\mathbf{I}-\mathbf{A})=0\)</span></li><li>顺序主子式全大于零</li></ul><h2 id="二海塞矩阵hessian-matrix">二、海塞矩阵(Hessian Matrix)</h2><p><span class="math display">\[\nabla^2f(\mathbf{x})=\begin{bmatrix}    \dfrac{\partial^2 f}{\partial x_1^2} &amp; \dfrac{\partial^2f}{\partial x_1 \partial x_2} &amp; \cdots &amp; \dfrac{\partial^2f}{\partial x_1 \partial x_n} \\    \dfrac{\partial^2 f}{\partial x_2 \partial x_1} &amp;\dfrac{\partial^2 f}{\partial x_2^2} &amp; \cdots &amp;\dfrac{\partial^2 f}{\partial x_2 \partial x_n} \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    \dfrac{\partial^2 f}{\partial x_n \partial x_1} &amp;\dfrac{\partial^2 f}{\partial x_n \partial x_2} &amp; \cdots &amp;\dfrac{\partial^2 f}{\partial x_n^2} \\\end{bmatrix}\]</span></p><h2 id="三求多元函数极值">三、求多元函数极值</h2><h3 id="求出驻点">1.求出驻点</h3><p>对多元函数<spanclass="math inline">\(f\)</span>求一阶偏导，让它等于0求出驻点</p><p><span class="math display">\[\dfrac{\partial f}{\partialx}=\begin{pmatrix}   \dfrac{\partial f}{\partial x_1}\\   \dfrac{\partial f}{\partial x_2}\\   \vdots\\   \dfrac{\partial f}{\partial x_n}\\\end{pmatrix}=0\]</span></p><h3 id="判断是不是极值点">2.判断是不是极值点</h3><p>驻点可能会有多个，假设下面是其中一个驻点</p><p><span class="math display">\[x=\begin{pmatrix}   x_1^*\\   x_2^*\\   \vdots\\   x_n^*\\\end{pmatrix}\]</span></p><p>将其带入到海塞矩阵中，判断海塞矩阵的正负定性。</p><ul><li>海塞矩阵正定，该点是极小值点</li><li><span class="math inline">\(f(x)\)</span> 的极大值是 <spanclass="math inline">\(-f(x)\)</span> 的极小值</li></ul><p>求极值： <spanclass="math display">\[f(x)=x^4+8x^3+22x^2+24x\]</span></p><hr /><h2 id="四凸集和凸函数">四、凸集和凸函数</h2><h3 id="凸集">1.凸集</h3><p><strong>定义</strong> ：<span class="math inline">\(D\subset\mathbb{R}^n，\forall x, \quad y \in D，\forall \lambda\in[0,1]满足\lambda x(1-\lambda)y\in D\)</span>，称D为凸集合</p><p><strong>特点</strong>：即内部无洞，边缘无内凹，任意两点间的连线仍然在集合内部</p><p><strong>性质</strong> :</p><ul><li>若<span class="math inline">\(D\)</span>，<spanclass="math inline">\(A\)</span>都为凸集，则<spanclass="math inline">\(\mathbf{D} \bigcap\mathbf{A}\)</span>，仍为凸集</li><li></li></ul><p><strong>常见的凸集</strong> <span class="math inline">\(\alpha \in\mathbb{R}^n\)</span></p><ul><li><strong>超平面</strong> ：<span class="math inline">\(H=\left \{x\in \mathbb{R}^n | \alpha^T x=b \right \}\)</span></li><li><strong>半空间（闭）</strong> ：<span class="math inline">\(H=\left\{x \in \mathbb{R}^n | \alpha^T x\le b \right \}，H=\left \{x \in\mathbb{R}^n | \alpha^T x\ge b \right \}\)</span></li><li><strong>半空间（开）</strong> ：半空间（闭）去掉<spanclass="math inline">\(\alpha^T x=b\)</span></li></ul><p>对与上面这三种的证明方法一致，这里以超平面为例： <spanclass="math display">\[\alpha \left [\lambda x + (1-\lambda)y \right ] =b(\lambda + 1 - \lambda) = b\]</span>上面简单证明了超平面为凸集</p><p>证明<span class="math inline">\(\mathcal{L}=\left \{x\in\mathcal{R}^n|x=x_0+\lambda d \right\}\)</span>，为凸集，<spanclass="math inline">\(d,x_0\)</span>是给定非零向量, <spanclass="math inline">\(\lambda\)</span>为任意实数，其证明方法也是与上面一致的，只需要将数据带入就行。</p><h3 id="凸函数">2.凸函数</h3><p>对于一个非空凸集<span class="math inline">\(S\)</span></p><p>函数<span class="math inline">\(f:D \to R\)</span></p><p><span class="math inline">\(\forall x, y \in D\)</span>，<spanclass="math inline">\(\forall \alpha \in[ 0,1 ]\)</span></p><p><span class="math inline">\(f[ \alpha x + (1-\alpha)y ] \le  \alphaf(x) + (1-\alpha)f(y)\)</span></p><p>则<spanclass="math inline">\(f\)</span>为凸函数，其实就是一种图像上直观的关系，不过观察并不能判断整个实数域上的情况</p><p><spanclass="math inline">\(f\)</span>上取两点可以做一条弦，在这两点之间函数的图像部分不在这条弦上方，对于所有的弦都成立就是凸函数</p><p>二次函数<spanclass="math inline">\(f(x)=x^2\)</span>很明显就是一个凸函数</p><p>当不存在相等情况时为严格凸函数</p><p>线性函数一定是凸函数 <span class="math display">\[f(x)=c_1 x_1 + c_2x_2 + c_3 x_3 + \ldots + c_n x_n\]</span> 可以写成<spanclass="math inline">\(f(x) = c^Tx\)</span></p><p>证明： <span class="math display">\[\begin{aligned}   f[\alpha x + (1-\alpha) y] &amp; = c^T[\alpha x + (1-\alpha)y] \\                              &amp; = c^T \alpha x + c^T (1-\alpha)y \\                              &amp; = \alpha c^T x + (1-\alpha) c^T y \\                              &amp; = \alpha f(x) + (1-\alpha)f(y)\end{aligned}\]</span></p><p><span class="math inline">\(f(x) = \max \{x_1, x_2, \ldots ,x_n\}\)</span>也是凸函数</p><h4 id="根据海塞矩阵判断凸函数">根据海塞矩阵判断凸函数</h4><ul><li>半正定：<span class="math inline">\(\nabla^2f(x) \ge  0 \Rightarrow凸函数\)</span></li><li>正定：<span class="math inline">\(\nabla^2f(x) &gt; 0 \Rightarrow严格凸函数\)</span></li></ul><h4 id="凸函数性质">凸函数性质</h4><p>局部最小即全局最小</p><h2 id="线性规划linear-programming">线性规划(Linear Programming)</h2><p>如:求<span class="math inline">\(\min z = c_1 x_1 + c_2 x_2 + \ldots+c_n x_n = c^T x\)</span></p><ul><li>决策变量(<span class="math inline">\(x_1, x_2, \ldots,x_n\)</span>)</li><li>目标函数(<span class="math inline">\(\min z, \max z\)</span>)</li><li>约束条件</li></ul><p>如：求<span class="math inline">\(\min z = 4x_1 + 2x_2 + 3x_3 +6x_4\)</span> <span class="math display">\[s.t = \begin{cases}   &amp; x_1 - 2x_2 + 3x_3 - 2x_4 \le  -6 \\   &amp; 2x_1 + 7x_2 - 6x_3 + x_4 \ge  7 \\   &amp; 3x_1 - x_2 + 2x_3 - 5x_4 = -8 \\   &amp; x_1 \ge  0,\quad x_2 \le  0,\quad x_3&lt;=0,\quad x_4\in\mathbb{R}\end{cases}\]</span></p><ul><li><strong>决策变量</strong> ：<span class="math inline">\(x_1,\quadx_2,\quad x_3,\quad x_4\)</span></li><li><strong>目标函数</strong> ：<span class="math inline">\(\min z =4x_1 + 2x_2 + 3x_3 + 6x_4\)</span></li></ul><h3 id="标准型stand-form">标准型(Stand Form)</h3><p>所有变量均不小于零，约束条件均为 <strong>等式</strong>且<strong>右侧常量为非负数</strong></p><p>上面这个例子可以通过替换变量和加入变量化为标准型 <spanclass="math display">\[\min z = 4x_1 + 2x_2 + 3x_3 + 6x_4\]</span> <spanclass="math display">\[s.t = \begin{cases}   &amp; x_1 - 2x_2 + 3x_3 - 2x_4 \le  -6 \\   &amp; 2x_1 + 7x_2 - 6x_3 + x_4 \ge  7 \\   &amp; 3x_1 - x_2 + 2x_3 - 5x_4 = -8 \\   &amp; x_1 \ge  0,\quad x_2 \le  0,\quad x_3 \le 0,\quad x_4\in\mathbb{R}\end{cases}\]</span></p><ul><li><span class="math inline">\(x_2&#39; = -x_2\)</span>替换<spanclass="math inline">\(x_2\)</span></li><li><span class="math inline">\(x_3&#39; = -x_3\)</span>替换<spanclass="math inline">\(x_3\)</span></li><li><span class="math inline">\(x_4&#39; -x_4&#39;&#39;\)</span>替换<spanclass="math inline">\(x_4\)</span>，让<span class="math inline">\(\quadx_4&#39;,\quad x_4&#39;&#39; \ge 0\)</span></li></ul><p><span class="math display">\[\min z = 4x_1 - 2x_2&#39; - 3x_3&#39; +6(x_4&#39; - x_4&#39;&#39;)\]</span> <span class="math display">\[s.t =\begin{cases}   &amp; -x_1 - 2x_2&#39; + 3x_3&#39; + 2(x_4&#39; - x_4&#39;&#39;) \ge6 \\   &amp; 2x_1 - 7x_2&#39; + 6x_3&#39; + x_4&#39; - x_4&#39;&#39; \ge 7\\   &amp; -3x_1 - x_2&#39; + 2x_3&#39; + 5(x_4&#39; - x_4&#39;&#39;) = 8\\   &amp; x_1,\quad x_2&#39;,\quad x_3&#39;, \quad x_4&#39;, \quadx_4&#39;&#39; \ge 0\end{cases}\]</span></p><p>接下来要把约束条件变为等式，要引入盈余变量(SurplusVariables)使约束条件化为等式</p><ul><li>引入的盈余变量也要为非负数</li></ul><p>因此可以减去一个引入的非负盈余变量使右端化为零</p><p>引入盈余变量<span class="math inline">\(s_1,\quad s_2\)</span></p><p><span class="math display">\[\min z = 4x_1 - 2x_2&#39; - 3x_3&#39; +6(x_4&#39; - x_4&#39;&#39;)\]</span> <span class="math display">\[s.t =\begin{cases}   &amp; -x_1 - 2x_2&#39; + 3x_3&#39; + 2(x_4&#39; - x_4&#39;&#39;) -s_1 = 6 \\   &amp; 2x_1 - 7x_2&#39; + 6x_3&#39; + x_4&#39; - x_4&#39;&#39; - s_2 =7 \\   &amp; -3x_1 - x_2&#39; + 2x_3&#39; + 5(x_4&#39; - x_4&#39;&#39;) = 8\\   &amp; x_1,\quad x_2&#39;,\quad x_3&#39;, \quad x_4&#39;, \quadx_4&#39;&#39;, \quad s_1,\quad s_2 \ge 0\end{cases}\]</span> 到这就化成标准型了</p><h3 id="基本可行解basic-feasible-solution">基本可行解(Basic FeasibleSolution)</h3><p>对于一个标准型<span class="math inline">\(\max f(x) = c^Tx\)</span></p><p>约束条件<span class="math inline">\(A x= b\)</span> <spanclass="math display">\[A x=\begin{pmatrix}   a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\   a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\   \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\   a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\\end{pmatrix}\begin{pmatrix}   x_1 \\   x_2 \\   \vdots \\   x_n\end{pmatrix}=\begin{pmatrix}   b_1 \\   b_2 \\   \vdots \\   b_n\end{pmatrix}\]</span></p><p>要从这个矩阵函数的解中找出使<spanclass="math inline">\(f(x)\)</span>最大的那个解，线性规划这一点很奇妙，其解集为凸集，类似于两个变量线性规划问题</p><p>两个变量约束可以很容易画出其解集，然后找一条跟目标函数平行的线在图像上平移，初中很多这种问题，<strong>能使目标函数最大或最小的解总在多边形的顶点上</strong></p><p><strong>线性规划问题对应的线性方程组的解集一定是凸集</strong>，因为其解集为每一个约束条件的解集的交集，凸集的交集一定是凸集。</p><p>解集是凸集的话，对于不是唯一解的情况下，它如果最优解一定是在凸多边形（凸多面体）的顶点，除了解集在某个方向无限延伸，目标函数无界的情况</p><p><strong>矩阵函数</strong> <span class="math display">\[A_{m \timesn}x\]</span></p><table><thead><tr><th style="text-align: center;">自然定义域</th><th style="text-align: center;">映射法则</th><th style="text-align: center;">值域</th><th style="text-align: center;">到达域</th></tr></thead><tbody><tr><td style="text-align: center;"><spanclass="math inline">\(\mathbb{R}^n\)</span></td><td style="text-align: center;"><spanclass="math inline">\(A\)</span></td><td style="text-align: center;"><spanclass="math inline">\(colsp(A)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\mathbb{R}^m\)</span></td></tr></tbody></table><p>其值域是对<spanclass="math inline">\(A\)</span>列向量的线性组合，对应空间中的一块区域，</p><p>根据线性规划约束条件的系数矩阵，选出一组 <strong>基向量</strong>（即一个极大无关列向量组） 对应的变量作为 <strong>基变量</strong>，其余作为 <strong>非基变量</strong></p><p>将<span class="math inline">\(A\)</span>分块分为两部分：<strong>基向量组成的基矩阵</strong> <spanclass="math inline">\(B\)</span> 和<strong>非基向量组成的非基矩阵</strong><spanclass="math inline">\(N\)</span></p><p><span class="math inline">\(A = [B|N]\)</span></p><p>约束条件变为</p><p><span class="math inline">\(B x_B + N x_N = b\)</span></p><p><strong>基本解</strong> ：令非基变量<spanclass="math inline">\(x_N\)</span>等于<spanclass="math inline">\(0\)</span>，解出：<span class="math inline">\(x_B= B^{-1}b\)</span></p><p><strong>基本可行解</strong>：基本解中 <span class="math inline">\(x_B\ge0\)</span>的解，在约束条件中对所有变量的约束是非负，只有这种才是有效的解</p><p>为什么要找基本解呢？刚才分析过了他的最优解是在凸多面体的顶点上</p><p>求<span class="math inline">\(\min z = x_1 + 2x_2 + 3x_3\)</span>假如说我有三个变量：<span class="math inline">\(x_1,\quad x_2,\quadx_3\)</span></p><p>其中前两个是基变量对应的基向量分别为 <span class="math display">\[p_1=\begin{pmatrix}   1\\   0\end{pmatrix},\quadp_2 =\begin{pmatrix}   0\\   1\\\end{pmatrix},\quadp_3 =\begin{pmatrix}   1\\   1\end{pmatrix}\]</span></p><p><span class="math inline">\(A x = [B|N] x = b\)</span> <spanclass="math display">\[\begin{pmatrix}   1 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 1\end{pmatrix}\begin{pmatrix}   x_1\\   x_2\\   x_3\end{pmatrix}=\begin{pmatrix}   2\\   1\end{pmatrix}\]</span></p><p>矩阵的秩为2</p><p><span class="math inline">\(p_1,\quadp_2\)</span>确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到<spanclass="math inline">\(b\)</span>就是对应的那个解 <spanclass="math inline">\(\begin{pmatrix}   2\\   1\\   0\end{pmatrix}\)</span></p><p><span class="math inline">\(p_1,\quadp_3\)</span>确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到<spanclass="math inline">\(b\)</span>就是对应的那个解 <spanclass="math inline">\(\begin{pmatrix}   1\\   0\\   1\end{pmatrix}\)</span></p><p><span class="math inline">\(p_2,\quadp_3\)</span>确定了一个向量空间，一个平面，这个向量空间中的某些向量可以映射到<spanclass="math inline">\(b\)</span>就是对应的那个解 <spanclass="math inline">\(\begin{pmatrix}   0\\   -1\\   2\end{pmatrix}\)</span></p><p>这三个点确定了一条直线（仅有一个自由变量）</p><p>每一个变量的取值都是在不同方向上贡献变化，把三个变量当作三个方向：即三个不同的轴向，其中两个方向可以构成一个平面，线性规划的求解，<strong>要求全为正数</strong></p><p>让其中非基变量等零，可以找出与三个平面的交点，边界条件，一定是在顶点上的，如果解集是直线则是线段的端点</p><p>添加盈余变量后，应该是贡献的轴向变多，对应的基本可行解集合是升维后的解集其他非基变量没有贡献时候的交点，是一个顶点（其他任何一个变量发生变化都会往不同的方向贡献），因此这个点一定是顶点</p><h3 id="单纯形表法">单纯形表法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最优化理论学习笔记&quot;&gt;最优化理论学习笔记&lt;/h1&gt;
&lt;p&gt;目的： 找到解决问题的最佳方法&lt;/p&gt;
&lt;p&gt;问题分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数极值&lt;span class=&quot;math inline&quot;&gt;&#92;(f(x)&#92;)&lt;/span&gt;：静态优化&lt;/li&gt;
</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>GCC基本使用</title>
    <link href="https://remermagors.github.io/archives/21724/"/>
    <id>https://remermagors.github.io/archives/21724/</id>
    <published>2025-10-13T02:25:31.000Z</published>
    <updated>2025-10-15T09:08:03.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一.单个文件编译">一.单个文件编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -v -Wall xxx.c -o xxx<br></code></pre></td></tr></table></figure><ul><li><code>-Wall</code>在编译时对一些常见错误，潜在问题给出警告，方便发现问题，修正代码</li><li><code>-o</code> <strong>output</strong> 指定编译生成的文件名<ul><li>可以顺便指定目录</li></ul></li><li><code>-v</code> 列出一些详细信息，当编译出错时会非常有用<ul><li>搜寻<strong>头文件（header files）</strong> 和<strong>库文件（libraries）</strong>的目录</li><li>用于链接的<strong>目标文件（objectfiles）</strong>和<strong>库文件（libraries）</strong></li></ul></li></ul><h1 id="二.多个文件编译">二.多个文件编译</h1><h2 id="独立编译">1.独立编译</h2><p>每个文件编译后生成一个 <strong>目标文件（object file）</strong>，而不产生可运行文件，产生对应的<code>.O</code>或者<code>.obj</code>文件,</p><p><strong>独立编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall -c xxx.c<br></code></pre></td></tr></table></figure><p><code>-c</code>产生相应的目标文件，这一步同样可以用<code>-o</code>参数指定文件名，否则与源文件同名</p><h2 id="链接">2.链接</h2><p>所有的目标文件通过连接器(linker)链接在一起，产生一个独立的可运行文件。</p><p><strong>链接</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc xxx.o yyyy.o -o Name<br></code></pre></td></tr></table></figure>对于较大的工程，将所有源码写在一个源文件中每次修改重新编译很费时。这时候需要将源文件模块化编程，每次只需要重新编译修改过的部分. ###2.1链接顺序</p><p>gcc无需指定链接顺序，对较老的编译器，有可能需要指定顺序，调用函数者放在前，定义函数者放在后。</p><h2 id="重编译重链接">3.重编译重链接</h2><p>对发生改变的源文件重新编译，再重新链接</p><h1 id="三.链接外部库">三.链接外部库</h1><h2 id="链接外部库的方式">1.链接外部库的方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall main.c /usr/lib/libm.a -o xxx<br></code></pre></td></tr></table></figure><p>绝对路径链接目标库<code>libm.a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall main.c -lNAME -o xxx<br>gcc -Wall main.c /usr/lib/libm.a -o xxx //与下面作用相同<br>gcc -Wall main.c -lm io xxx<br></code></pre></td></tr></table></figure><p>对于库文件<code>libNAME.a</code>,可以用<code>-lNAME</code>链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall main.c -L<span class="hljs-variable">$LibPath</span> -lNAME<br></code></pre></td></tr></table></figure><h2 id="搜索路径">搜索路径</h2><p><code>-I</code>和<code>-L</code>参数指定搜索路经</p><ul><li><code>-I</code>指定头文件搜索目录</li><li><code>-L</code>指定库文件搜索目录</li></ul><h1 id="使用ar创建一个库">使用<code>ar</code>创建一个库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ar cr libNAME.a file1.o file2.o ... filen.o<br></code></pre></td></tr></table></figure><p><code>cr</code></p><ul><li><code>c</code> create 创建</li><li><code>r</code> replace 替换</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ar t libNAME.a<br></code></pre></td></tr></table></figure><p>列出<code>libNAME.a</code>里的目标文件</p><h2id="创建一个库libtest.a并使用">创建一个库<code>libTEST.a</code>并使用</h2><h3 id="创建头文件和源码">1.创建头文件和源码</h3><p><code>libTEST.h</code>,<code>func1.c</code>,<code>func2.c</code>,<code>main.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c:func1.c">//func1.c<br>#include &quot;libTEST.h&quot;<br>int func1(int x, int y)&#123;<br>    return (x+y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c:func2.c">//func2.c<br>#include &lt;stdio.h&gt;<br>void func2(int x)&#123;<br>    printf(&quot;Result = %d&quot;, x);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c:libTEST.h">//libTEST.h<br>#ifndef __LIBTEST_H__<br>#define __LIBTEST_H__ <br><br>int func1(int x, int y);<br>void func2(int x);<br><br>#endif <br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c:main.c">//main.c<br>#include &quot;libTEST.h&quot;<br>int main()&#123;<br>    int i;<br>    i = func1(1, 2);<br>    func2(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建目标文件">2.创建目标文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall -c func1.c func2.c<br></code></pre></td></tr></table></figure><p>此时产生目标文件<code>func1.o</code>,<code>func2.o</code></p><h3 id="将目标文件创建成库">3.将目标文件创建成库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ar cr libTEST.a func1.o func2.o<br></code></pre></td></tr></table></figure><p>生成了库文件<code>libTEST.a</code></p><h3 id="使用库文件">4.使用库文件</h3><p>在编译时链接刚刚创建的库<code>libTEST.a</code>，要将<code>main.c</code>放在<code>libTEST.a</code>之前</p><p>!⭕!库文件<code>.a</code>为二进制文件。<code>main.c</code>调用<code>libTEST.a</code>，放在前面。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall main.c libTEST.a<br></code></pre></td></tr></table></figure> OR 添加搜索库路径参数 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -Wall main.c -L. -lTEST<br></code></pre></td></tr></table></figure>运行输出文件，程序结果为<code>3</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一.单个文件编译&quot;&gt;一.单个文件编译&lt;/h1&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>十月周末总结</title>
    <link href="https://remermagors.github.io/archives/19160/"/>
    <id>https://remermagors.github.io/archives/19160/</id>
    <published>2025-10-12T12:25:15.000Z</published>
    <updated>2025-10-15T12:39:58.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次周末总结">第一次周末总结</h2><h3 id="月6---10月12">10月6 - 10月12</h3><p>6号是中秋节，10月1 —10月8是国庆和中秋假期，整个国庆假期都在学校，每天打打CS2。国庆假期升级了电脑的内存，换了两根24GDDR55600MHz的内存条，原来的是两根8G实在是有点不够用。SW开个模型就要报内存可使用内存不够用。刚开始还计划假期几天出去玩玩，比如去龙潭山，朱雀山看看吉林的秋景。最后这八天都没有出去走一走。</p><p>中秋节晚上和舍友邓一块去了河南街的福源馆，买了几个月饼，说实话这个月饼中规中矩，吃起来没有什么特别的，就是一种很熟悉的味道，但是挺贵的，最便宜的六块五一个。我买了两个六块五的，一个八块的，到宿舍给了舍友一个。从9号开始上课到12号，周六补了10月八号的课。</p><h3 id="学习方面">学习方面</h3><h4 id="物理">物理</h4><p>假期补了前面的一点作业，是关于光的偏振的，自然光光强<spanclass="math inline">\(I_0\)</span>透过偏振片后光强变为原来的一半<spanclass="math inline">\(I_1=I_0/2\)</span>，产生的线偏振光与的振动方向与另一个偏振片的偏振化方向夹角<spanclass="math inline">\(\alpha\)</span>，则透射光的光强<spanclass="math inline">\(I = I_1\cos^2\alpha\)</span> 上面这个就是<strong>（马吕斯定律）</strong> 证明：是将入射光的光矢量振幅<spanclass="math inline">\(E_0\)</span>分成 <strong>垂直</strong> 和<strong>平行</strong> 于偏振片偏振化方向的分量 <spanclass="math inline">\(E_0\sin\alpha\)</span> 和 <spanclass="math inline">\(E_0\cos\alpha\)</span>，光强与振幅的二次方成正比，<spanclass="math inline">\(\begin{gather*}\frac{I}{I_1}=\frac{(E_0\cos\alpha)^2}{E_0^2}\end{gather*}\)</span></p><p>上课新学习了电场强度通量，和高斯定理。电场强度通量在书中是这么说的：<strong>通过电场中任一给定面积的电场线根数，称为通过该面积的电场强度通量,用<spanclass="math inline">\(\Phi_e\)</span>表示</strong>。感觉这是一种很好理解<strong>高斯定理</strong> 的方式。 <strong>高斯定理</strong> 的表述：<strong>穿过任意闭合曲面的电场强度通量，等于曲面内所包围的全部电荷的电荷量的代数和除以<spanclass="math inline">\(\varepsilon_0\)</span></strong>。</p><p><span class="math inline">\(\begin{gather*}\Phi_e=\oint_S E\cdot\,d\mathrm{S}=\frac{1}{\varepsilon_0}\sum_{i=1}^{n} q_i\end{gather*}\)</span></p><p>然后又学了电势差，电势，上课算了一些常见的物理模型：（下次补充）</p><h4 id="单片机">51单片机</h4><ul class="task-list"><li><label><input type="checkbox"checked="" />点亮一颗LED，LED流水灯，独立按键控制LED状态，独立按键控制LED移位</label></li><li><label><input type="checkbox"checked="" />数码管静态显示，动态显示</label></li></ul><p>在控制LED的编程过程中用到的较多的是 - 2进制和16进制转换 - 按位取反 -延时</p><p>数码管操作起来比LED复杂许多，掌握74HC138译码器使用实现数码管的位选，74HC245控制段选，对于动态显示要消影。</p><h4 id="电路原理">电路原理</h4><h4 id="最优化理论">最优化理论</h4><p>目的： 找到解决问题的最佳方法 问题分类： - 函数极值<spanclass="math inline">\(f(x)\)</span>：静态优化 - 泛函极值<spanclass="math inline">\(f(u+v)\)</span>：动态优化</p><h4 id="体育课3200m">体育课3200M</h4><p>跑了 13’28”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一次周末总结&quot;&gt;第一次周末总结&lt;/h2&gt;
&lt;h3 id=&quot;月6---10月12&quot;&gt;10月6 - 10月12&lt;/h3&gt;
&lt;p&gt;6号是中秋节，10月1 —
10月8是国庆和中秋假期，整个国庆假期都在学校，每天打打CS2。国庆假期升级了电脑的内存，换了两根24G</summary>
      
    
    
    
    <category term="life" scheme="https://remermagors.github.io/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Latextest</title>
    <link href="https://remermagors.github.io/archives/10000/"/>
    <id>https://remermagors.github.io/archives/10000/</id>
    <published>2025-10-07T14:35:41.000Z</published>
    <updated>2025-10-15T08:54:20.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="latex-希腊字母表">latex 希腊字母表</h1><table><thead><tr><th style="text-align: center;">Latex</th><th style="text-align: center;">小写符号</th><th style="text-align: center;">Latex</th><th style="text-align: center;">大写符号</th></tr></thead><tbody><tr><td style="text-align: center;"><code>\alpha</code></td><td style="text-align: center;"><spanclass="math inline">\(\alpha\)</span></td><td style="text-align: center;"><code>\mathrm{A}</code></td><td style="text-align: center;"><spanclass="math inline">\(\mathrm{A}\)</span></td></tr><tr><td style="text-align: center;"><code>\beta</code></td><td style="text-align: center;"><spanclass="math inline">\(\beta\)</span></td><td style="text-align: center;"><code>\mathrm{B}</code></td><td style="text-align: center;"><spanclass="math inline">\(\mathrm{B}\)</span></td></tr><tr><td style="text-align: center;"><code>\gamma</code></td><td style="text-align: center;"><spanclass="math inline">\(\gamma\)</span></td><td style="text-align: center;"><code>\Gamma</code></td><td style="text-align: center;"><spanclass="math inline">\(\Gamma\)</span></td></tr><tr><td style="text-align: center;"><code>\delta</code></td><td style="text-align: center;"><spanclass="math inline">\(\delta\)</span></td><td style="text-align: center;"><code>\Delta</code></td><td style="text-align: center;"><spanclass="math inline">\(\Delta\)</span></td></tr><tr><td style="text-align: center;"><code>\zeta</code></td><td style="text-align: center;"><spanclass="math inline">\(\zeta\)</span></td><td style="text-align: center;"><code>\Zeta</code></td><td style="text-align: center;"><spanclass="math inline">\(\Zeta\)</span></td></tr><tr><td style="text-align: center;"><code>\epsilon</code></td><td style="text-align: center;"><spanclass="math inline">\(\epsilon\)</span></td><td style="text-align: center;"><code>\mathrm{E}</code></td><td style="text-align: center;"><spanclass="math inline">\(\mathrm{E}\)</span></td></tr><tr><td style="text-align: center;"><code>\eta</code></td><td style="text-align: center;"><spanclass="math inline">\(\eta\)</span></td><td style="text-align: center;"><code>Eta</code></td><td style="text-align: center;"><spanclass="math inline">\(\Eta\)</span></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;latex-希腊字母表&quot;&gt;latex 希腊字母表&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;Latex&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;小</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://remermagors.github.io/archives/16107/"/>
    <id>https://remermagors.github.io/archives/16107/</id>
    <published>2025-10-07T03:02:38.715Z</published>
    <updated>2025-10-04T07:37:09.351Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C语言初识之猜数游戏</title>
    <link href="https://remermagors.github.io/archives/26716/"/>
    <id>https://remermagors.github.io/archives/26716/</id>
    <published>2025-10-03T14:29:34.000Z</published>
    <updated>2025-10-07T14:17:28.576Z</updated>
    
    <content type="html"><![CDATA[<p>转入自动化专业之后以后的学习会用到C语言，本来自动化专业大一就学过<strong><em>《C语言程序设计》</em></strong>，所以我需要对这一门课程进行补修。刚好我也对这方面感兴趣，顺便提前学习了一点点，现在我自学的基本都是看菜鸟教程和一点点实践出来的。突发奇想写个猜数字的游戏，很简陋，只有命令行界面。这个文章简要记录了我这个程序的变化及想法的实现。</p><p>我刚开始是只写了能运行一次的，也就是下面这个流程，但是玩完一次还得再去运行，不能直接再次开始游戏，想再玩的话很麻烦，还得再打开一次。然后就想办法让他能再次运行，我的想法是通过一个<code>while</code>循环来实现，先定义了循环变量<code>r</code>并初始化为2，然后输出<strong>游戏开始[1]</strong> 和 <strong>退出选项[2]</strong>引导玩家去输入选择开始或者退出游戏，当输入<code>1</code>就开始游戏，这里直接选择了小于等于1开始循环。然后初始化<strong>随机数发生器</strong>，从1-100选择一个数作为这次游戏的答案，定义并初始化用于记录尝试次数的变量<code>n = 1</code>，因为就算第一次输入正确也是尝试了1次，定义用于玩家输入的变量<code>x</code>，告知游戏规则，由玩家输入数字，输入不等于答案时告知大小关系，变量<code>n</code>加1，告知玩家再次尝试，这是为了玩家清楚现在的状态，不是死机。当输入等于答案时退出这层循环，然后输出尝试次数和正确答案，询问是否再玩一次，再次由玩家输入到变量<code>r</code></p><pre><code class="hljs mermaid">---config:    theme: neutral    layout: dagre---flowchart TD    A[&quot;猜数游戏&quot;]    answer[&quot;随机生成答案&quot;]    input[&quot;输入&quot;]    false[&quot;记录尝试次数，告知与答案大小关系&quot;]    true[&quot;输出尝试次数，正确答案&quot;]    stop[&quot;结束游戏&quot;]    A --&gt;|告知规则| answer    answer --&gt; input    input --&gt; |猜错| false    input --&gt; |猜对| true    false --&gt; input    true --&gt; stop</code></pre><p>修改后的流程图和代码是这样的，算是一个很简单的小游戏了</p><pre><code class="hljs mermaid">---config:  theme: neutral  layout: dagre---flowchart TD    A[&quot;猜数游戏&quot;] --&gt;|输入1| C(&quot;随机生成答案&quot;)    A --&gt;|输入2| D(&quot;结束游戏&quot;)    C --&gt; E(&quot;猜数&quot;)    E --&gt;|猜对| F(&quot;尝试次数，正确答案&quot;)    E --&gt;|猜错| G(&quot;告知与答案大小关系&quot;)    G --&gt;|记录尝试次数| E    F --&gt; A    R(告知规则) --&gt; A</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tGuess NUMBER game\t\n\n\t    [1]Start\t\n\n\t    [2]EXIT\t\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;r);<br>    <span class="hljs-keyword">while</span>( r &lt;= <span class="hljs-number">1</span> ) <span class="hljs-comment">// 开始游戏</span><br>    &#123;<br>        srand((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)time(<span class="hljs-literal">NULL</span>));<br>        <span class="hljs-type">int</span> answer = rand() % <span class="hljs-number">101</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 从1-100随机选取一个数字</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于记录尝试次数的变量</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tGuess a NUMBER from 1 to 100\t\n\nI&#x27;ll tell you whether IT is bigger or smaller\nin comparison with the NUMBER i selected\n\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Enter Your ANSWER: &quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <span class="hljs-keyword">while</span>(x != answer) <span class="hljs-comment">// 猜错开始循环</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(x &lt; answer) <span class="hljs-comment">// 输入小于答案</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your answer is Smaller\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 输入大于答案</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your answer is Bigger\n&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Try again: &quot;</span>);<br>            n++;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You&#x27;ve tried %d times, the Answer is %d\n&quot;</span>, n, answer);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[1] PLAY AGAIN\n[2] EXIT.....\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <strong><em>《软件技术基础》</em></strong>这门刚开始学的课程中老师讲的算法的<strong>时间复杂度</strong>，讲了<strong>大O表示法（BigO Notation）</strong>，举了一些例子</p><ul><li><strong>O(1) 常数时间</strong></li><li><strong>O(log n) 对数时间</strong></li><li><strong>O(n) 线性时间</strong></li><li><strong>O(n log n) 线性对数时间</strong></li><li><strong>O(n^2) 平方时间</strong></li><li><strong>O(2^n) 指数时间</strong></li><li><strong>O(n!) 阶乘时间</strong>现在我还是不会算一些循环的时间复杂度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转入自动化专业之后以后的学习会用到C语言，本来自动化专业大一就学过
&lt;strong&gt;&lt;em&gt;《C语言程序设计》&lt;/em&gt;&lt;/strong&gt;
，所以我需要对这一门课程进行补修。刚好我也对这方面感兴趣，顺便提前学习了一点点，现在我自学的基本都是看菜鸟教程和一点点实践出来的。</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>金工实习</title>
    <link href="https://remermagors.github.io/archives/15058/"/>
    <id>https://remermagors.github.io/archives/15058/</id>
    <published>2025-09-22T14:39:28.000Z</published>
    <updated>2025-11-06T16:04:30.664Z</updated>
    
    <content type="html"><![CDATA[<p>我在大二转入了自动化专业，金工实习对我来说不单单是一门需要完成的课程，因为我对机械加工这一块非常感兴趣，这种兴趣应该是从小时候玩玩具可拆东西开始的。</p><p>一次一次的拆卸组装玩具和一些电器让我想自己动手去做一些东西，家中凡是买来的玩具和一些容易拆卸的电器，无一是没有被我拆过的。最早的大概是玩具枪，记得小时候玩的五块钱一个的玩具手枪有点劣质但是威力并不算小，有个缺点就是气缸和扳机之间的部分容易变形，导致玩具枪报废，还找不到单卖气缸和扳机的，我就想着能不能把气缸和扳机换成金属部件。延长玩具枪的使用寿命。</p><p>大二终于有了尝试机械加工的机会，每节金工实习我都听的很认真，操作也是非常认真，争取操作机会，目前金工实习才上了一点，所有实践内容大概就是下面这些</p><ul><li><p><strong><a href="#1">车工</a></strong></p></li><li><p><strong><a href="#2">3D打印</a></strong></p></li><li><p><strong>钳工</strong></p></li><li><p><strong>激光</strong></p></li><li><p><strong>铸造</strong></p></li><li><p><strong>锻压</strong></p></li><li><p><strong>焊接</strong></p></li><li><p><strong>铣削</strong></p></li></ul><h2 id="车工"><strong>车工</strong><a id = "1"></a></h2><p>先学的就是车工，我们学了普通卧式车床和数控车床的基本操作。<strong>普通卧式车床</strong>的操作，我们课上用的是塑料件，第一节课是老师讲完车床的基本操作之后给演示车一个小阶梯轴，在第一节课老师就给了我们组操作机会，我感觉很幸运。第二次去上课就是让我们每个组都车那个演示的小阶梯轴，第一次是我们三个人每人操作一步，但是车出之后零件的误差很大，能差上个2毫米还多。我们分析了其中的原因，应该是每次往里进刀的时候都重新读数导致的误差。</p><p>当时时间还很充足，我提出一个人单独车一个零件。我是第一个操作的，这次我从刚开始读数后一直加着数算，没有重新读数，车好零件之后用游标卡尺测量，肉眼看到零刻度线是正对着主尺上的刻度线的，误差很小，但是后面的那个倒角没有车。这次没有在工料上划线，导致车出来的边缘有点翘边，这次还忘了车端面。</p><p><strong>数控车床</strong>实操的东西不多，学习了简单的对刀，还了解了一点编程。不过刚开始看到数控车床的时候看到操作面板上那么多的按钮真的不知所措，最后只是演示了一下一个工件的加工，并没有让我们实际动手去操作。</p><h2 id="d打印"><strong>3D打印</strong><a id = "2"></a></h2><p>这个恰逢国庆假期调课，是早上八点的课，我一觉醒来已经八点十几了，匆匆忙忙赶到教室去上课，差点以为要完蛋了，因为金工实习不让我们迟到。不过老师很好，给了我机会，让我签到了。第一节课我们讲的是CATIA建模，教了一些基本操作，好在我之前在SolidWorks里面学习建模吊钩的时候都学过了这些简单的基本操作。</p><p>第二次去教室让我们每人带一个U盘，存放我们自己建的模型，下节课用于打印。下午去了3D打印实训室，我中午挑时间学着建模了CS2的骷髅匕首，我感觉这把刀的设计很有美感，想打印出来玩一玩。但是打印的时候总是先两边翘边，然后就从底板上脱落了，试了好多次都不行，就让别人先打印了，结果我们这台机器到最后只有一个底面是圆的成功了。</p><p><img src="https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPZo36dvn0yOP782SvegFq0UCCN0oAACFh0AAmyk-FbOgg7t1iS9ZjYE.png" title="" alt="" data-align="center"></p><p><img title="" src="https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAEDHPlo36gIgtOQasiCCTjTbTYHQWVULQACGR0AAmyk-FYLOtJJiHfI9TYE.png" alt="" data-align="center"></p><p>下节课尝试一下立着打印，把与底板的接触面积减小，减小因温度降低的收缩量</p><p><strong><em>2025/11/6</em></strong></p><p>已经好多天没写金工实习的东西了，最近很忙，今天晚上熄灯了，暂时还不想睡觉，有点焦虑感，趁着这个时候写一下分散一下注意力</p><p>3D打印上次重试了，第一节课还是没成功打出来，总是脱落，到那调过喷头的高度之后又试着横着打印，打印不出来，总是脱落</p><p>上半节课基本都浪费在调参数上了，到最后还是老师帮忙调了一下参数，先让其他同学打印的他们的模型，下半节课快结束的时候我开始打印的骷髅匕首，打印时间花了20多分钟，到下课后十来分钟才打印好，中间等待的过程既是激动又是期待，总害怕突然脱落了。</p><p>在打印开始前我根据底板上留下的痕迹调了一下模型的位置，为了防止脱落，竖着打印确实是好了。这个底板上基本只有左上角那一块能粘上，竖着的话可以减小与底板的接触面积，直觉告诉我这样会粘的更好一点，调的位置刚好避开了底板上中间的那个孔洞，当时看到这点还是很爽的。</p><p>现在这个骷髅匕首已经成为我的书签了，总之还是很有纪念意义的。</p><h2 id="钳工">钳工</h2><p>这个工种我也是非常期待的，感觉还算顺利，就是难度比我想象中的高了一点。</p><p>这个工种的种子大概是在我很小的时候就在萌发了（写到这勾起了我的童年回忆），小学一二年级的时候，我和当时的好朋友就在路边寻找小红砖块，然后打磨这个砖块，当时真是下课就去学校篮球场的水泥地上磨砖块，磨出了地上一大片砖红色的痕迹，磨成各种形状，印象最深的就是球，正方体和子弹了。</p><p>尤其是子弹，小时候（现在也是）对枪械充满向往，幻想着有朝一日能打上真枪，打上真子弹，于是把砖块磨成子弹的形状，我磨了很多很多个。</p><p>我感觉对子弹头的处理是最麻烦的，小砖块在粗糙的水泥地上摩擦的时候很容易就把尖给崩断，而且在那磨出来的表面划痕还很严重，后来就开始蘸水然后在细一点的墙面上磨。</p><p>为了让弹头和后面接近圆柱的部分过渡光滑，我边转边磨，最后效果也是很好，摸上去看上去都是很完美的曲线。现在想想我当时也还是充满想象力，又有动手能力。</p><p>又或许当时这也东西也为我空间想象力和几何直觉奠定了一定的基础，让我感觉初高中几何，除了圆锥曲线计算那边:( 都还是非常简单的 :)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我在大二转入了自动化专业，金工实习对我来说不单单是一门需要完成的课程，因为我对机械加工这一块非常感兴趣，这种兴趣应该是从小时候玩玩具可拆东西开始的。&lt;/p&gt;
&lt;p&gt;一次一次的拆卸组装玩具和一些电器让我想自己动手去做一些东西，家中凡是买来的玩具和一些容易拆卸的电器，无一是没</summary>
      
    
    
    
    <category term="note" scheme="https://remermagors.github.io/categories/note/"/>
    
    
  </entry>
  
</feed>
